<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title>Towers of Annoy</title>
        <script src="./jquery-3.6.0.min.js"></script>	
        <script src="./BufferLoader.js"></script>
        <script src="./abcjs-basic-min.js" type="text/javascript"></script>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div id='toa'>
            <h1>Towers of Annoy</h1>
            <div id="board">                
            </div>
            <div id="board_base">                
            </div>
            <div id="abc"></div>
            <div id="controls">
                <div class="uirow sectiontitle">
                    <label class="fieldname">Game</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Number of pegs</label>
                    <input type="range" min="3" max="8" value="3" class="slider" id="slider_pegs">
                    <label class="slidervalue" id="label_pegs"></label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Number of disks</label>
                    <input type="range" min="1" max="15" value="3" class="slider" id="slider_disks">
                    <label class="slidervalue" id="label_disks"></label>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Notation</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Time signature</label>
                    <input type="range" min="1" max="12" value="4" class="slider" id="slider_timesignature">
                    <label class="slidervalue" id="label_timesignature"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">General appearance</label>
                    <input type="checkbox" id="checkbox_colornotes" name="colornotes" unchecked>Color note by disk</input>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Audio</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Volume</label>
                    <input type="range" min="1" max="1000" value="700" class="slider" id="slider_volume">
                    <label class="slidervalue" id="label_volume"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">BPM</label>
                    <input type="range" min="10" max="480" value="60" class="slider" id="slider_bpm">
                    <label class="slidervalue" id="label_bpm"></label>
                </div>             
                <div class="uirow sectiontitle">
                    <label class="fieldname">Playback</label>
                </div>
                <div class="uirow">
                    <input type="checkbox" id="checkbox_addreverse" name="addreverse" unchecked>Add reverse</input>
                    <input type="checkbox" id="checkbox_loop" name="loop" unchecked>Loop</input>
                    <button id="button_step">Step</button>
                    <button id="button_play">Play</button>
                    <button id="button_reset">Reset</button>
                    <label class="slidervalue" id="label_moves"></label>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Instrument preview:</label>
                </div>
                <div class="uirow">
                    <div id="preview_buttons"></div>                    
                </div>               
            </div>
        </div>
    </body>

<script type="module">

// Read the GET URL variables and return them as an associative array.
function getUrlVars() {
    var vars = {}

    if (window.location.href.indexOf('?') != -1) { 
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for (var i = 0; i < hashes.length; i++)
        {
            var hash = hashes[i].split('=');
            vars[hash[0]] = decodeURI(hash[1]);
        }
    }

    return vars;
}

var updatingUI;

function set_playing(val) {
    playing = val;
    $('#button_play').text(playing ? 'Stop' : 'Play');
}

function update_ui(e) {
    // don't recurse here if we internally update UI controls.
    if (updatingUI) { return };
    updatingUI = true;

    // console.log('update_ui()');

    var v;
    
    pegs = parseInt($('#slider_pegs').val());
    $('#label_pegs').text(pegs);

    disks = parseInt($('#slider_disks').val());
    $('#label_disks').text(disks);

    v = parseInt($('#slider_volume').val())/1000;
    $('#label_volume').text(Math.floor(v*100) + "%");
    if (gain_node) {
        gain_node.gain.value = Math.pow(v, 2);
    }

    bpm = parseInt($('#slider_bpm').val());
    $('#label_bpm').text(bpm);
    
    loop = ($('#checkbox_loop').prop('checked'));
    addreverse = ($('#checkbox_addreverse').prop('checked'));

    timesignature = parseInt($('#slider_timesignature').val());
    $('#label_timesignature').text(timesignature + '/4');
    
    // Stop playback if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        reset();
    } 

    // Reinitialize board if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        init_board();
    } 

    // Rerender notation
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks')
        || (e.target.id=='checkbox_loop')
        || (e.target.id=='checkbox_addreverse')
        || (e.target.id=='checkbox_colornotes')
        || (e.target.id=='slider_timesignature')
    )) {
        abc_render();
    } 
    
    updatingUI = false;
}

const available_samples = [
    'samples/kick-808.wav',
    'samples/clap-808.wav',
    'samples/hihat-808.wav',
    'samples/snare-808.wav',
    'samples/openhat-808.wav',
    'samples/kick-plain.wav',
    'samples/perc-808.wav',
    'samples/tom-808.wav'
];

var pegs;
var disks;
var bpm;
var timesignature;
var loop;
var addreverse;

var analyser_node;
var compressor_node;
var gain_node;
var saved_instruments = [];

var fft_array;
var audio_context;
var instrument_buffers;

var moves = [];
var current_move = 0;
var note_play_count = 0;
var abc_note_index = 0;
var playing = false;
var reverse = false;
var play_move_timer;
var glow_deactivation_timer;
var reset_before_next_move = false;

const MAXABC = 1024;

// One note per possible peg.
const abcnotes = 'EFGABc\'d\'e\'f\'g\'a\'b\'';

// Calculate the moves for a given game of the Towers of Hanoi. Moves 
// are pushed onto the moves-array in format [source, target].
function Hanoi(pegs, disks) {
    console.log('Hanoi(' + pegs + ',' + disks + ')');

    var board = [];

    // Represent the board as a string for logging/debugging. 
    function boardtostr() {

        var boardstr = '';

        for(var peg = 0 ; peg<pegs ; peg++) {
            boardstr += '#' + peg + ':['; 
            boardstr += board[peg].join(', ') + '] ';            
        }
        
        return boardstr;
    }

    // Process a move from source to target. This updates the internal board representation
    // for logging and debugging. Also push the move to the global moves-array.
    function move(source, target) {    
        var disk = board[source].pop();
        board[target].push(disk);
    
        moves.push([source, target, disk]);
        // console.log('#' + moves.length + ': Disk ' + disk + ' + from #' + source + ' to #' + target + '  -  ' + boardtostr());
    }   
    // Main bit: Implements the Frame-Stewart-algorithm.
    function solve(level, disks, source, dest, intermediates) {

        // console.log(level + 'solve(' + disks + ', ' + source + ', ' + dest + ', [' + intermediates.join(',') + '])');

        if (disks == 1) {
            move(source, dest);
        } else {
            var p;

            // Copy intermediates for recursion:
            intermediates = intermediates.slice();

            // Pick a number of disks to move.
            if (intermediates.length >= 2) {
                p = Math.floor(disks/2);
            } else {
                p = disks - 1;
            }

            // Move top p disks from source to one intermediate
            var intermediate = intermediates.pop();
            intermediates.push(dest);
            solve(level + '   ', p, source, intermediate, intermediates);

            // Move the rest of the disks from source to dest
            intermediates.pop();
            solve(level + '   ', disks - p, source, dest, intermediates);

            // Move p disks from chosen intermediate to the final peg
            intermediates.push(source);
            solve(level + '   ', p, intermediate, dest, intermediates);
        }
    }

    // Reset moves array.
    moves = []
    current_move = 0;
    reverse = false;

    // Build initial board representation: Array of pegs each with an array 
    // of disk-numbers on them.
    for(var peg = 0 ; peg<pegs ; peg++) {
        board.push([]);
    }

    // Put all the disks on the first peg.
    for(var disksize = disks ; disksize>0 ; disksize--) {
        board[0].push(disksize);
    }

    // Create an array of all the available intermediate pegs.
    var available_intermediates = [];
    for(var peg = 1 ; peg<pegs-1 ; peg++) {
        available_intermediates.push(peg);
    }

    console.log('Start: ' + boardtostr());

    solve('', disks, /* source */ 0, /* target */ pegs-1, available_intermediates);
    
    console.log('Solved in ' + moves.length + ' moves.');
}

function get_disk_color(disk)
{
    // Map the disk 0..disks-1 to a HSL hue between min_hue and max_hue.
    var min_hue = 240
    var max_hue = 0;
    
    var hue;
    if (disks == 1) {
        hue = min_hue;
    } else {
        hue = (disk - 1) / (disks - 1) * (max_hue - min_hue) + min_hue;
    }

    var colString = "hsl(" + hue + ",100%,50%)";
    
    return colString;
}

function create_pegs() {
    // Save the selected instruments for all current pegs.
    
    var oldpegs = $('.instrument_select').length;

    for (var peg = 0; peg<oldpegs ; peg++) {
        if (peg >= saved_instruments.length) {
            saved_instruments.push(-1);
        } else {
            var instrument_id = $('#instrument' + peg).val();
            if (instrument_id) {
                saved_instruments[peg]=instrument_id;
            }
        }
    }

    $('#board').empty();
    $('#board_base').empty();
    
    // Create pegs
    for (var peg = 0; peg<pegs ; peg++) {
        $('#board').append('<div class="peg" id="peg' + peg + '"></div>');

        $('#board_base').append('<div class="peg_base" id="peg_base' + peg + '"><select class="instrument_select glower" id="instrument' + peg + '"></select></div>');
        $('#instrument' + peg).append('<option value="-1">Silent</option>');
        for(var sampleindex = 0; sampleindex<available_samples.length; sampleindex++) {
            $('#instrument' + peg).append('<option value="' + sampleindex + '">' + available_samples[sampleindex].substring('samples/'.length) + '</option>');
        }

        // Re-select previously selected instrument.
        if (peg < saved_instruments.length) {
            $('#instrument' + peg).val(saved_instruments[peg]);
        }

        $('#instrument' + peg).on("change", play_select_instrument_preview);
    }
}    

function create_disks() {
    // Create all required disks as DIV on peg#
    for(var disk = 1 ; disk<=disks ; disk++) {
        $('#peg0').append('<div class="disk" id="disk' + disk + '"><div class="disk_body"></div></div>');
        $('#disk' + disk + ' .disk_body').width(disk + 'em').css('background', get_disk_color(disk)); 
    }

    // Resize board.
    $('#board').css('height', (3+disks) + 'em');
}

function update_moves_label() {
    $('#label_moves').text('move ' + (current_move+1) +' of ' + moves.length);
}

function remove_all_glow() {
    $('.instrument_select').removeClass('glower_active');
    if (glow_deactivation_timer) {
        clearTimeout(glow_deactivation_timer);
        glow_deactivation_timer = 0;
    }
}
    
function play_instrument(instrument) {
    var source = audio_context.createBufferSource();
        source.buffer = instrument_buffers[instrument];
        source.connect(gain_node);
        source.start();
}

function play_select_instrument_preview(e) {
    if (e) {
        play_instrument($('#' + e.target.id).val())
    }
}

function play_button_instrument_preview(e) {
    if (e) {
        play_instrument(e.target.id.substr('button_instrument_'.length))
    }
}

function abc_render() {
    $('#abc').empty();

    // Only render for a certain maximum of moves.
    var notecount = moves.length * (loop ? 2 : 1);
    if (notecount > MAXABC) {
        $('#abc').html('Too long to score').css('height', '');
        return;
    }

    // Create the abc-string for the current solution. Including reversal and looping.
    var abc_string =
        'L: 1/4\n' + 
        'M: ' + timesignature  + '/4\n' +
        'K: C style=x\n';
        
    if (loop) {
        abc_string += '|:';
    }    

    notecount = 0;
    var disksequence = [];
    
    for(var noteindex = 0 ; noteindex < moves.length; noteindex++) {
        
        // Record sequence of disks so we can color notes respectively. 
        disksequence.push(moves[noteindex][2]);
        
        // Add note or rest depending on the instrument selected.
        var selected_instrument = $('#instrument' + moves[noteindex][1]).val();
        if (selected_instrument == -1) {
            abc_string += 'z '; // rest
        } else {
            abc_string += abcnotes[selected_instrument] + ' ';
        }
        
        notecount++;

        // Add bar line if we have finished a bar AND are not done with the whole piece.
        if ((reverse || (noteindex < moves.length-1)) && (notecount % timesignature) == 0) {
            abc_string += '|';
        }
    }

    if (addreverse) {
        for(var noteindex = moves.length-1 ; noteindex >= 0; noteindex--) {
        
            // Record sequence of disks so we can color notes respectively. 
            disksequence.push(moves[noteindex][2]);
        
            // Add note or rest depending on the instrument selected.
            var selected_instrument = $('#instrument' + moves[noteindex][0]).val();
            if (selected_instrument == -1) {
                abc_string += 'z '; // rest
            } else {
                abc_string += abcnotes[selected_instrument] + ' ';
            }
        
            notecount++;

            // Add bar line if we have finished a bar AND are not done with the whole piece.
            if ((noteindex >= 0) && (notecount % timesignature == 0)) {
                abc_string += '|';
            }
        }
    }

    /*
    // Add rests to complete the final bar.
    while (notecount % timesignature) {
        abc_string += 'z ';
        notecount++;
    }
    */

    // Add final bar line.
    if (loop) {
        abc_string += ':';
    }

    abc_string += '|]';

    ABCJS.renderAbc("abc", abc_string, {
        add_classes: true,
        wrap: {
            minSpacing: 1,
            maxSpacing: 1,
            preferredMeasuresPerLine: 12
        },
        staffwidth: $('#abc').width()*0.8
    });

    // Color notes by disk
    if ($('#checkbox_colornotes').prop('checked')) {
        for (noteindex = 0; noteindex < disksequence.length; noteindex++) {
            var disk = disksequence[noteindex];
            var color = get_disk_color(disk);             
            var measure = Math.floor(noteindex / timesignature);
            var note = noteindex % timesignature; 

            $('.abcjs-mm' + measure + '.abcjs-n' + note).css('fill', color);
        }
    }
}

function play_move() {
    
    var source = moves[current_move][0];
    var target = moves[current_move][1];
    
    update_moves_label();
    
    if (reverse) {
        // Swap source and target.
        var tmp = source;
        source = target;
        target = tmp;
    }

    // console.log('play_move(' + current_move + ') from #' + source + ' to #' + target);

    // If we looped in the last step we now need to intantly put back all
    // disks on peg 0.
    if (reset_before_next_move) {
        $('.disk').remove();
        create_disks();
        reset_before_next_move = false;
    }

    // Make visual move:
    // Get the top disk from the source peg.
    var disk = $('#peg' + source + ' div.disk').first();
    // And drop it onto the target peg.
    $('#peg' + target).prepend(disk);

    // Playback of selected instrument.
    remove_all_glow();

    var selected_instrument = $('#instrument' + target).val();
    if (selected_instrument != -1) {
        $('#instrument' + target).addClass('glower_active');
        glow_deactivation_timer = setTimeout(remove_all_glow, 1000);

        play_instrument(selected_instrument);
    }

    // Highlight current notation or rest in the abc notation.
    var abcmeasure = Math.floor(abc_note_index / timesignature);
    var abcnote = abc_note_index % timesignature; 

    $('.abcjs-note').removeClass('current_note');
    $('.abcjs-mm' + abcmeasure + '.abcjs-n' + abcnote).addClass('current_note');

    // Overall notes played. This only resets on a new start.
    note_play_count++;
    
    // What note within the abc-notation is played next? This only resets after a full loop.
    abc_note_index++;

    // Figure out next move to play. This is complicated by the loop- and addreverse-options.
    if (!reverse) {
        // Playing forward.
        current_move = current_move + 1;
        if (current_move == moves.length) {
            // Reached the end. Do we want to play in reverse next?
            if (addreverse) {
                // Yes. Set reverse flag and adjust current_move.
                reverse = true;
                current_move = moves.length-1;
            } else {
                // No. Don't reverse.
                current_move = 0;
                abc_note_index = 0;
                reset_before_next_move = true;
            
                // Loop?
                if (!loop) {
                    // No. Stop. But we are ready to restart on the next click on play.
                    set_playing(false);              
                } 
            }
        }
    } else {
        // Playing in reverse.
        current_move = (current_move-1);
        if (current_move == -1) {
            // Back at the start. Are we looping?           
            reverse = false;
            current_move = 0;
            abc_note_index = 0;

            if (!loop) {
                // Not looping. Stop. But we are ready to start playing again.
                set_playing(false);
            }
        }
    } 
    
    // Still playing? Schedule next move.
    if (playing) {
        play_move_timer = setTimeout(play_move, (60/bpm*1000));
    } else {
        play_move_timer = null;
    }
}

function step() {
    console.log('step()');

    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);

    play_move();
}

function play() {
    console.log('play()');

    if (playing) {
        // Pause
        if (play_move_timer) {
            clearTimeout(play_move_timer);
            play_move_timer = null;
        }
        set_playing(false);
    } else {
        // Play
        set_playing(true);
        if (!play_move_timer) {
            play_move();
        }
    }
}

function reset() {
    console.log('reset()');

    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);
    
    init_board();
}

function init_board() {
    console.log('init_board()');
    
    Hanoi(pegs, disks);
    update_moves_label();

    // Update Screen to initial conditions
    
    // Clear all pegs and disks
    create_pegs();
    create_disks();

    current_move = 0;
    note_play_count = 0;
    abc_note_index = 0;
    
    abc_render();
}

$(document).ready(function() {

    // window.AudioContext = window.AudioContext  || window.webkitAudioContext;
    audio_context = new AudioContext();
    
    analyser_node = audio_context.createAnalyser();
    analyser_node.fftSize = 128;
    fft_array = new Uint8Array(analyser_node.frequencyBinCount);

    gain_node = audio_context.createGain();
    // gain_node.gain.value = Math.pow(volumeSlider.value/1000, 2);
    
    compressor_node = audio_context.createDynamicsCompressor();

    gain_node.connect(compressor_node);
    compressor_node.connect(analyser_node);
    analyser_node.connect(audio_context.destination);

    for(var sample_index = 0; sample_index < available_samples.length ; sample_index++) {
        $('#preview_buttons').append('<button class="button_instrument" id="button_instrument_' + sample_index + '">' + available_samples[sample_index].substr('samples/'.length) + '</button>');            
    }
    $('.button_instrument').click(play_button_instrument_preview);

    new BufferLoader(
        audio_context,
        available_samples,
        function(data) {
            console.log('Samples loaded.');

            instrument_buffers = data;

            // Default instruments in order of samples. 
            for(var instrument = 0 ; instrument<available_samples.length ; instrument++) {
                saved_instruments.push(instrument);
            }

            update_ui();
            init_board();            
        }
    ).load();

    $('#slider_pegs').on("input change", update_ui);
    $('#slider_disks').on("input change", update_ui);
    $('#slider_volume').on("input change", update_ui);
    $('#slider_bpm').on("input change", update_ui);
    $('#slider_timesignature').on("input change", update_ui);
    
    $('#checkbox_loop').on("change", update_ui);
    $('#checkbox_addreverse').on("change", update_ui);
    $('#checkbox_colornotes').on("change", update_ui);

    $( "#button_step" ).click(step);
    $( "#button_play" ).click(play);
    $( "#button_reset" ).click(reset);

    var urlvars = getUrlVars();

    update_ui();
})

</script>

</html>

