<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <link rel="icon" href="/favicon.png" type="image/png">
        <title>Towers of Annoy</title>
        <script src="./jquery-3.6.0.min.js"></script>	
        <script src="./abcjs-basic-min.js" type="text/javascript"></script>
        <script src="./recorder.js"></script>
        <script src="./moment.js"></script>
        <link rel="stylesheet" href="style.css">
        <link rel="stylesheet" href="style-dark.css" id="style_darkmode" disabled="true">
    </head>
    <body>
        <div id='toa'>
            <h1>Towers of Annoy</h1>
            <p>For more information see <a href="https://marian-aldenhoevel.de/towers-of-annoy/">https://marian-aldenhoevel.de/towers-of-annoy/</a></p>
            <p>TL;DR:</p>
            <ol>
                <li>Click play</li>
                <li>Change number of pegs or disks and other settings and click play</li>
                <li>Select instruments or drag them from the preview area to pegs</li>
                <li>Copy the notation and try playing it on a real instrument</li>
                <li>Copy a preset from the URL and share it!</li>
            </ol>
            <div id="sticky">
                <div class="uirow board">
                    <button class="button_step" accesskey="s">Step</button>
                    <button class="button_play" accesskey="p">Play</button>
                    <button class="button_reset">Reset</button>
                    <label class="slidervalue label_moves" id="label_moves1"></label>
                    <label class="slidervalue" id="label_moves">&nbsp;&nbsp;<em>(For more controls see below)</em></label>
                </div>    
                <div id="board">                
                </div>
                <div id="board_base">                
                </div>
                <div id="analyser_container">
                    <canvas id="analyser"></canvas>
                </div>
            </div>
            <div id="abc"></div>
            <div id="controls">
                <div class="uirow sectiontitle">
                    <label class="fieldname">Game</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Number of pegs</label>
                    <input type="range" min="3" max="8" value="3" class="slider" id="slider_pegs">
                    <label class="slidervalue" id="label_pegs"></label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Number of disks</label>
                    <input type="range" min="1" max="15" value="3" class="slider" id="slider_disks">
                    <label class="slidervalue" id="label_disks"></label>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Notation</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Time signature</label>
                    <input type="range" min="1" max="12" value="4" class="slider" id="slider_timesignature">
                    <label class="slidervalue" id="label_timesignature"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">General appearance</label>
                    <input type="checkbox" id="checkbox_colornotes" name="colornotes" unchecked>Color note by disk</input>
                    <input type="checkbox" id="checkbox_darkmode" name="darkmode" unchecked>Dark mode</input>
                </div>
                <div class="uirow">
                    <label class="fieldname">abc notation string&nbsp;<a href="http://abcnotation.com/wiki/abc:standard:v2.1" target="_blank">[?]</a></label>
                    <textarea id="textarea_abc_string" readonly></textarea>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Audio</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Volume</label>
                    <input type="range" min="1" max="1000" value="700" class="slider" id="slider_volume">
                    <label class="slidervalue" id="label_volume"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">BPM</label>
                    <input type="range" min="10" max="480" value="240" class="slider" id="slider_bpm">
                    <label class="slidervalue" id="label_bpm"></label>
                </div>             
                <div class="uirow sectiontitle">
                    <label class="fieldname">Playback</label>
                </div>
                <div class="uirow">
                    <input type="checkbox" id="checkbox_addreverse" name="addreverse" unchecked>Add reverse</input>
                    <input type="checkbox" id="checkbox_loop" name="loop" unchecked>Loop</input>
                </div>
                <div class="uirow">
                    <button class="button_step" accesskey="s">Step</button>
                    <button class="button_play" accesskey="p">Play</button>
                    <button class="button_reset">Reset</button>
                    <label class="slidervalue label_moves" id="label_moves2"></label>
                </div>
                <div class="uirow" id="div_record">
                    <button id="button_record" accesskey="s">Start Recording</button>                    
                </div>
                <div class="uirow sectiontitle" id="sample_library">
                    <label class="fieldname">Sample library:</label>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Upload custom sample</label>
                </div>
                <div class="uirow">
                    <input id="file_custom_sample" type="file" accept="audio/*"/>
                    <label>abc note&nbsp;<a href="http://abcnotation.com/wiki/abc:standard:v2.1#pitch" target="_blank">[?]</a>&nbsp;<input id="text_custom_sample_note" type="text" maxlength="4" style="width: 3em;"/>
                    <button id="button_custom_sample_library" disabled>Preview</button>
                    <button id="button_custom_sample_add" disabled>Add</button>
                </div>               
            </div>
        </div>
    </body>

<!-- Catalog of inbuilt available samples. Generated by code from folder contents -->
<script src="./sample_catalog.js"></script>
        
<script>

// A list of notes that can be used in abc notation 
var abc_notes = [
    'A,,',     'B,,',     'C,,',     'D,,',     'E,,',     'F,,',     'G,,',
    'A,',      'B,',      'C,',      'D,',      'E,',      'F,',      'G,',
    'A',       'B',       'C',       'D',       'E',       'F',       'G',
    'a',       'b',       'c',       'd',       'e',       'f',       'g',
    'a\'',     'b\'',     'c\'',     'd\'',     'e\'',     'f\'',     'g\'',
    'a\'\'',   'b\'\'',   'c\'\'',   'd\'\'',   'e\'\'',   'f\'\'',   'g\'\'',
    'a\'\'\'', 'b\'\'\'', 'c\'\'\'', 'd\'\'\'', 'e\'\'\'', 'f\'\'\'', 'g\'\'\'',
];

// Names for indices into the sample library arrays.
const SAMPLE_ID = 0;
const SAMPLE_URL = 1;
const SAMPLE_ABC_NOTE = 2;
const SAMPLE_BUFFER = 3;

// Name and ID fpr the Custom category of samples.
const INST_CUSTOM = 'Custom';

// What instrument and notes are selected? This is an array indexed by peg.
// Each entry holds an array of:
//   #0: instrument name
//   #1: samples-id unique for that instrument
var selected_samples = [];

// Some more variables holding settings made in the UI. For convenience. See update_ui().
var pegs;
var disks;
var bpm;
var timesignature;
var loop;
var addreverse;

// Audio-API objects.
var analyser_node;
var compressor_node;
var gain_node;
var fft_array;
var audio_context;

// Stuff for rendering the spectrum-analyser. 
var analyser_canvas;
var analyser_context;

// Recorder.js and a flag indicating wether we are recording at the moment.
var recorder;
var recording = false;

// Variables for the state of play.
var moves = [];
var current_move = 0;
var reached_end = false;
var note_play_count = 0;
var abc_note_index = 0;
var playing = false;
var reverse = false;
var play_move_timer;
var glow_deactivation_timer;
var reset_before_next_move = false;

// These hold data for custom samples being uploaded until they are added to the
// sample library.
var custom_sample_file = null;
var custom_sample_buffer = null;

// During drag-operations this holds information about the instrument/sample that is being dragged.
var sample_being_dragged = null;

// Limit on the notes that we are willing to render online as SVG. An arbitrary performance-cutoff.
const MAXABC = 1024;

// Are we currently updating the UI? A recursion-stopper.
var updating_ui;

function update_url() {
    // Create a linkeable URL to capture the current setup.
    
    // console.log('update_url()');
    
    var url = window.location.protocol + '//' + window.location.host + window.location.pathname;

    url += '?pe=' + pegs;
    url += '&di=' + disks;
    url += '&bpm=' + bpm;
    url += '&vo=' + $('#slider_volume').val();
    url += '&lo=' + (loop ? 1 : 0);
    url += '&ar=' + (addreverse ? 1 : 0);
    url += '&ts=' + timesignature;
    url += '&cn=' + ($('#checkbox_colornotes').prop('checked') ? 1 : 0);
    url += '&dm=' + ($('#checkbox_darkmode').prop('checked') ? 1 : 0);

    for(var peg = 0; peg < Math.min(selected_samples.length, pegs); peg++) {
        if (selected_samples[peg][0] && selected_samples[peg][1]) {
            url += '&in' + peg + '=' + selected_samples[peg][0]; 
            url += '&sa' + peg + '=' + selected_samples[peg][1];
        }
    }

    history.replaceState(null, '', url);
}

function parse_url() {
    // Parse the query-string to recreate a saved setup from an URL.

    // console.log('parse_url()');
    
    var vars = {}
    if (window.location.href.indexOf('?') != -1) { 
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for (var i = 0; i < hashes.length; i++)
        {
            var hash = hashes[i].split('=');
            vars[hash[0]] = decodeURI(hash[1]);
        }
    }

    function set_slider(id, varname) {
        if (vars[varname]) {
            var v  = parseInt(vars[varname]);
            if (v && (!isNaN(v)) && (v >= $(id).prop('min')) && (v <= $(id).prop('max'))) {
                $(id).val(v);
            }
        }
    }

    function set_checkbox(id, varname) {
        if (vars[varname]) {
            $(id).prop('checked', (1 == vars[varname]))
        }
    }

    set_slider('#slider_pegs',           'pe');
    set_slider('#slider_disks',          'di');
    set_slider('#slider_bpm',            'bpm');
    set_slider('#slider_volume',         'vo');
    set_checkbox('#checkbox_loop',       'lo');
    set_checkbox('#checkbox_addreverse', 'ar');    
    set_slider('#slider_timesignature',  'ts');
    set_checkbox('#checkbox_colornotes', 'cn');
    set_checkbox('#checkbox_darkmode',   'dm');

    // Overwrite selected instrument for all pegs we possibly support as indicated
    // by the max property on the pegs slider.
    for (var peg = 0; peg < $('#slider_pegs').prop('max'); peg++) {
        var instrument = vars['in' + peg];
        var sample_id = vars['sa' + peg];

        if (instrument && sample_catalog.has(instrument)) {
            var sample_id_valid = (sample_id == 'silence');
            var samples = sample_catalog.get(instrument);
            
            for (var sample_index = 0; sample_index < samples.length; sample_index++) {
                if (sample_id == samples[sample_index][SAMPLE_ID]) {
                    sample_id_valid = true;
                    break;
                }
            }
        }
            
        if (sample_id_valid) {
            // Make room in the selected samples array by filling with silence.
            while (peg >= selected_samples.length) {
                selected_samples.push(['silence', 'silence']);
            }

            // And store.
            selected_samples[peg][0] = instrument;
            selected_samples[peg][1] = sample_id;
        }
    }
}

function update_ui(e) {
    // Update various globals based on settings on the UI. Also reflect
    // state back to UI.
    
    // don't recurse here if we internally update UI controls.
    if (updating_ui) { 
        return;
    };
    updating_ui = true;

    // console.log('update_ui()');

    var v;
    
    pegs = parseInt($('#slider_pegs').val());
    $('#label_pegs').text(pegs);

    disks = parseInt($('#slider_disks').val());
    $('#label_disks').text(disks);

    v = parseInt($('#slider_volume').val())/1000;
    $('#label_volume').text(Math.floor(v*100) + "%");
    if (gain_node) {
        gain_node.gain.value = Math.pow(v, 2);
    }

    bpm = parseInt($('#slider_bpm').val());
    $('#label_bpm').text(bpm);
    
    loop = ($('#checkbox_loop').prop('checked'));
    addreverse = ($('#checkbox_addreverse').prop('checked'));
    
    $('#style_darkmode').prop('disabled', !$('#checkbox_darkmode').prop('checked'));
    
    timesignature = parseInt($('#slider_timesignature').val());
    $('#label_timesignature').text(timesignature + '/4');
    
    // Stop playback if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        reset();
    } 

    // Rerender notation
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks')
        || (e.target.id=='checkbox_loop')
        || (e.target.id=='checkbox_addreverse')
        || (e.target.id=='checkbox_colornotes')
        || (e.target.id=='slider_timesignature')
    )) {
        abc_render();
    } 
    
    $('#button_custom_sample_library').prop('disabled', !(custom_sample_buffer));
    $('#button_custom_sample_add').prop('disabled', !(custom_sample_buffer));

    if (recording) {
        $('#button_record').html('Stop recording');
    } else {
        $('#button_record').html('Start recording');
    }

    // Disable note selects if "instrument" silence is selected.
    for(var peg = 0; peg < pegs; peg++) {
        $('#sample' + peg).prop('disabled', ($('#instrument' + peg).val() == 'silence'));
    }

    updating_ui = false;

    update_url();
}

function load_sample(instrument, note_index, callback) {
    // Load buffer for a sample asynchronously. Trigger callback when done.

    // console.log('load_sample(\'' + instrument + '\', ' + note_index + ')');

    var request = new XMLHttpRequest();
    request.open('GET', 'samples/' + sample_catalog.get(instrument)[note_index][SAMPLE_URL], true);
    request.responseType = 'arraybuffer';

    var loader = this;

    request.onload = function() {
        // Asynchronously decode the audio file data in request.response
        audio_context.decodeAudioData(
            request.response,
            function(buffer) {
                if (!buffer) {
                    console.error('Error decoding file data: ' + url);
                    return;
                }
                sample_catalog.get(instrument)[note_index].push(buffer);
                callback();
            },
            function(error) {
                console.error('Error in decodeAudioData()');
            }
        );
    }

    request.onerror = function() {
        console.error('Error in BufferLoader-XHR');
    }

    request.send();
}

// Buffer loader basics taken from http://www.html5rocks.com/en/tutorials/webaudio/intro/js/buffer-loader.js
// Load each instrument, decode the audio and put it into the slot in the instruments array. Fire a callback
// when all samples are loaded.
function BufferLoader(callback) {
    this.onload = callback;
}

BufferLoader.prototype.loaded_one = function() {
    
    var loader = this;
    
    loader.load_count--;
    if (loader.load_count == 0) {
        loader.onload();
    }
}

BufferLoader.prototype.load_all = function() {
    
    var loader = this;

    loader.load_count = pegs;

    // Preload all instruments that we are currently using.
    for (var peg = 0 ; peg<pegs ; peg++) {
        var instrument = $('#instrument' + peg).val();
        var sample_id = $('#sample' + peg).val();

        if ((instrument != 'silence') && (sample_id != 'silence')) {
            var samples = sample_catalog.get(instrument);
            for (var sample_index = 0; sample_index < samples.length; sample_index++) {
                if (samples[sample_index][SAMPLE_ID] == sample_id) {
                    if (!samples[sample_index][SAMPLE_BUFFER]) {
                        load_sample(instrument, sample_index, function() {
                            loader.loaded_one();
                        })
                    } else {
                        // Already loaded for this peg.
                        loader.loaded_one();
                    }
                }
            } // of loop to find sample_index
        } else {
            // No instrument here, no need to load for this peg.
            loader.loaded_one();
        }
    }
}

// Calculate the moves for a given game of the Towers of Hanoi specified
// by the number of pegs and disks. Moves are pushed onto the moves-array 
// in format [source, target, disk] for later iterative consumption.
function hanoi(pegs, disks) {
    console.log('hanoi(' + pegs + ',' + disks + ')');

    // Board-representation for debugging.
    var board = [];

    // Represent the board as a string for logging/debugging. 
    function boardtostr() {

        var boardstr = '';

        for(var peg = 0 ; peg<pegs ; peg++) {
            boardstr += '#' + peg + ':['; 
            boardstr += board[peg].join(', ') + '] ';            
        }
        
        return boardstr;
    }

    // Process a move from source to target. This updates the internal board representation
    // for logging and debugging. Also push the move to the global moves-array.
    function move(source, target) {    
        var disk = board[source].pop();
        board[target].push(disk);
    
        moves.push([source, target, disk]);
        // console.log('#' + moves.length + ': Disk ' + disk + ' + from #' + source + ' to #' + target + '  -  ' + boardtostr());
    }   

    // Main bit: Implements the Frame-Stewart-algorithm.
    function solve(level, disks, source, dest, intermediates) {

        // console.log(level + 'solve(' + disks + ', ' + source + ', ' + dest + ', [' + intermediates.join(',') + '])');

        if (disks == 1) {
            move(source, dest);
        } else {
            var p;

            // Copy intermediates for recursion:
            intermediates = intermediates.slice();

            // Pick a number of disks to move.
            if (intermediates.length >= 2) {
                p = Math.floor(disks/2);
            } else {
                p = disks - 1;
            }

            // Move top p disks from source to one intermediate
            var intermediate = intermediates.pop();
            intermediates.push(dest);
            solve(level + '   ', p, source, intermediate, intermediates);

            // Move the rest of the disks from source to dest
            intermediates.pop();
            solve(level + '   ', disks - p, source, dest, intermediates);

            // Move p disks from chosen intermediate to the final peg
            intermediates.push(source);
            solve(level + '   ', p, intermediate, dest, intermediates);
        }
    }

    // Reset moves array.
    moves = []
    current_move = 0;
    reverse = false;

    // Build initial board representation: Array of pegs each with an array 
    // of disk-numbers on them.
    for(var peg = 0 ; peg<pegs ; peg++) {
        board.push([]);
    }

    // Put all the disks on the first peg.
    for(var disksize = disks ; disksize>0 ; disksize--) {
        board[0].push(disksize);
    }

    // Create an array of all the available intermediate pegs.
    var available_intermediates = [];
    for(var peg = 1 ; peg<pegs-1 ; peg++) {
        available_intermediates.push(peg);
    }

    // console.log('Start: ' + boardtostr());

    solve('', disks, /* source */ 0, /* target */ pegs-1, available_intermediates);
    
    console.log('solved in ' + moves.length + ' moves');
}

function get_disk_color(disk, saturation, lightness) {
    // Map the disk 0..disks-1 to a HSL hue between min_hue and max_hue to
    // give a nice rainbow.

    var min_hue = 240
    var max_hue = 0;
    
    var hue;
    if (disks == 1) {
        hue = min_hue;
    } else {
        hue = (disk - 1) / (disks - 1) * (max_hue - min_hue) + min_hue;
    }

    var colString = 'hsl(' + hue + ',' + saturation + ',' + lightness + ')';
    
    return colString;
}

function create_pegs() {
    // Create DOM elements for the pegs and sample-selection.
    
    // console.log('create_pegs()');
    
    $('#board').empty();
    $('#board_base').empty();
    
    // For each peg
    for (var peg = 0; peg<pegs ; peg++) {
        
        // Peg-DIV on the board
        $('#board').append('<div class="peg" id="peg' + peg + '"></div>');

        // Peg-DIV for sample-selection. Holds a <select> each for instrument and note.
        $('#board_base').append(
            '<div class="peg_base dropzone" id="peg_base' + peg + '">' +
                '<select class="instrument_select glower" id="instrument' + peg + '"></select>' + 
                '<select class="sample_select glower" id="sample' + peg + '"></select>' + 
            '</div>'
        );
        
        $('#instrument' + peg).append('<option class="silence" value="silence">Silence</option>');
        
        // Add instruments.
        for (var instrument of sample_catalog.keys()) {
            $('#instrument' + peg).append('<option value="' + instrument + '">' + instrument + '</option>');
        }
        
        // Re-select previously selected sample for this peg.
        select_sample(peg);

        // Set up drop target events.
        $('.dropzone').on('dragover', sample_dragover);
        $('.dropzone').on('dragleave', sample_dragleave);
        $('.dropzone').on('drop', sample_drop);
        
        // Wire events to react on instrument and sample changes.
        $('#instrument' + peg).on("change", instrument_changed);
        $('#sample' + peg).on("change", sample_changed);
    }
}    

function create_disks() {
    // Create all required disks as DIV on peg #0
    for(var disk = 1 ; disk<=disks ; disk++) {
        $('#peg0').append('<div class="disk" id="disk' + disk + '"><div class="disk_body"></div></div>');
        $('#disk' + disk + ' .disk_body')
            .width(disk + 'em')
            .css('background-color',    get_disk_color(disk, '100%', '50%')) 
            .css('border-top-color',    get_disk_color(disk,  '80%', '40%'))
            .css('border-right-color',  get_disk_color(disk,  '80%', '20%'))            
            .css('border-bottom-color', get_disk_color(disk,  '80%', '20%'))
            .css('border-left-color',   get_disk_color(disk,  '80%', '40%')); 
    }

    // Resize board vertically to hold all disks and some space.
    $('#board').css('height', (3+disks) + 'em');
}

function update_moves_label() {
    // Update the current moves label in all places.
    $('.label_moves').text('move ' + (current_move+1) +' of ' + moves.length);
}

function remove_all_glow() {
    // Remove the glow-animation for currently playing stuff from
    // all places.

    $('.instrument_select').removeClass('glower_active');
    $('.sample_select').removeClass('glower_active');
    $('.button_sample_library').removeClass('glower_active');
    $('.abcjs-note').removeClass('current_note');
    $('.abcjs-rest').removeClass('current_note');
    
    // Deschedule a timed de-glow if there is one.
    if (glow_deactivation_timer) {
        clearTimeout(glow_deactivation_timer);
        glow_deactivation_timer = 0;
    }
}
    
function play_sample(instrument, sample_id) {
    // Play a sample identified by instrument and sample_id. May need to load
    // the sample from the server first. In which case we call ourselves back
    // when the XHR-request is complete.

    // console.log('play_sample(\'' + instrument + '\', \'' + sample_id + '\')');

    if (instrument && (instrument != 'silence') && (sample_id != 'silence')) {
        var samples = sample_catalog.get(instrument);
        for (var sample_index = 0; sample_index < samples.length; sample_index++) {
            if (samples[sample_index][SAMPLE_ID] == sample_id) {
                
                if (!samples[sample_index][SAMPLE_BUFFER]) {
                    // Sample not yet loaded. Do that now asynchronously and play as
                    // soon as we have it.
                    // console.log('Async load sample, play deferred.');
                    load_sample(instrument, sample_index, function() { 
                        play_sample(instrument, sample_id)
                    })
                } else {
                    // Sample already loaded. Play it.
                    var source = audio_context.createBufferSource();
                    source.buffer = samples[sample_index][SAMPLE_BUFFER];
                    source.connect(gain_node);
                    source.start();
                }

                break;
            }
        }
    }
}

function update_note_options(peg) {
    // Make sure the sample select <options> match the instrument 
    // selected on the peg.

    // console.log('update_note_options(' + peg + ')');

    $('#sample' + peg).empty();
    $('#sample' + peg).append('<option class="silence" selected value="silence"></option>');
    
    // Add all notes for the currently selected instrument.
    var notes = sample_catalog.get(selected_samples[peg][0]);
    if (notes) {
        for (var note_index = 0 ; note_index < notes.length; note_index++)  {
            $('#sample' + peg).append(
                '<option value="' + notes[note_index][SAMPLE_ID] + '" ' + 
                ((notes[note_index][SAMPLE_ID] == selected_samples[peg][1]) ? ' selected' : '') + 
                '>' + notes[note_index][SAMPLE_ID] + 
                '</option>'
            );
        }
    }        

    $('#sample' + peg).val();
}

function select_sample(peg) {
    // Make the visual selection on the UI reflect the selection in the 
    // selected_samples array.

    // Update note <options> if required.
    if ($('#instrument' + peg).val() != selected_samples[peg][0]) {            
        update_note_options(peg);
    }

    // Select instrument and note.
    $('#instrument' + peg).val(selected_samples[peg][0]);
    $('#sample' + peg).val(selected_samples[peg][1]);
}

function instrument_or_sample_changed(peg) {
    // A new sample has been selected by the user. Either through the instrument
    // or the sample_id. Play the new sample once and re-render the notation.
    var instrument = $('#instrument' + peg).val();
    var sample_id = $('#sample' + peg).val();

    play_sample(instrument, sample_id);
    abc_render();
}

function instrument_changed(e) {
    // The instrument selection on a peg has been changed by the user.
    
    if (updating_ui) {
        return;
    }

    // For wich peg are we called? Extract from the control id.
    var peg = e.target.id.substring('instrument'.length);

    // Update the selected sample instrument to the new value.
    selected_samples[peg][0] = $('#instrument' + peg).val();
    update_note_options(peg);

    // Try to select the same note for the new instrument. This will
    // fail if the new instrument does not support the note, update_note_options()
    // will have defaulted to silence. So read back the value in case we need
    // to mute.
    $('#sample' + peg).val(selected_samples[peg][1]);
    selected_samples[peg][1] = $('#sample' + peg).val();

    instrument_or_sample_changed(peg);

    update_ui(e);
}

function sample_changed(e) {
    // Sample selection on a peg has been changed by the user.
    
    if (updating_ui) {
        return;
    }
    
    // For wich peg are we called? Extract from the control id.
    var peg = e.target.id.substring('sample'.length);

    console.log(selected_samples);
    console.log(peg);

    // Update the selected sample note to the new value.
    selected_samples[peg][1] = $('#sample' + peg).val();

    instrument_or_sample_changed(peg)

    update_ui(e);
}

function parent_with_id(el) {
    // Returns el or the first parent up that has an ID attribute 
    var result = el;
    
    while (result && !result.id) {
        result = result.parentNode; 
    }

    return result;
}

function play_from_sample_library(e) {
    // Play a sample from a key or button from the sample-libary.

    var t = parent_with_id(e.target); 
    // console.log('play_from_sample_library("' + t.id + '")');
    
    var instrument = $(t).data('instrument');
    var sample_id = $(t).data('sample-id');

    play_sample(instrument, sample_id);
}

function abc_render() {
    // Create the abc-string for the current solution. Including reversal and looping. If still
    // within reason, render it as SVG.

    $('#abc').empty();
    $('#textarea_abc_string').empty();

    // Create one voice per used instrument
    var voices = new Map();
    for(var peg = 0; peg < pegs; peg++) {
        var instrument = selected_samples[peg][0];
        if (instrument != 'silence') {
            voices.set(instrument, 'V: ' + instrument + ' name="' + instrument + '" style=' + ((instrument=='Percussion') ? 'x' : 'normal') + ' clef=alto\n' + (loop ? '[|: ' : '')); 
        }
    }

    var abc_string =
        'L: 1/4\n' + 
        'M: ' + timesignature  + '/4\n' +
        'K: C\n';
        
    notecount = 0;
    var disksequence = [];
    
    // Find the notes per peg.
    var pegnotes = []
    for(var peg = 0; peg<pegs; peg++) {
        var instrument = selected_samples[peg][0];
        var sampleid = selected_samples[peg][1];
        var note = 'x';
        if (instrument && (instrument != 'silence') && (sampleid != 'silence'))  {
            // find the sample by id
            var samples = sample_catalog.get(instrument);
            for(var sample_index = 0; sample_index < samples.length; sample_index++) {
                if (samples[sample_index][SAMPLE_ID] == sampleid) {
                    note = samples[sample_index][SAMPLE_ABC_NOTE];
                    break; 
                }
            }
        }
        pegnotes.push(note);
    }

    function add_move(peg, disk) {
        // Record sequence of disks so we can color notes respectively. 
        disksequence.push(moves[noteindex][2]);
        
        // Add note or rest depending on the instrument selected.
        var instrument = selected_samples[peg][0];
        var note = pegnotes[peg];
                
        // Add the note to the correct voice and a placeholder to all others.
        for (var v of voices.keys()) {
            var voice_str = voices.get(v);
            if (v == instrument) {
                voice_str += note;
            } else {
                voice_str += 'x';
            }
            voice_str += ' ';
            voices.set(v, voice_str);
        } 
        
        notecount++;

        // Add bar line if we have finished a bar AND are not done with the whole piece.
        if ((noteindex > 0) && (notecount % timesignature) == 0) {
            for (var v of voices.keys()) {
                var voice_str = voices.get(v);
                voice_str += '|';
                voices.set(v, voice_str);
            }
        }
    }

    // Add moves going forward-
    for(var noteindex = 0 ; noteindex < moves.length; noteindex++) {
        add_move(moves[noteindex][1], moves[noteindex][2]);
    }

    // If required add moves goinf backwards.
    if (addreverse) {
        for(var noteindex = moves.length-1 ; noteindex >= 0; noteindex--) {
            add_move(moves[noteindex][0], moves[noteindex][2]);
        }
    }

    // Add final bar line.
    if (loop) {
        for (var v of voices.keys()) {
            var voice_str = voices.get(v);
            voice_str += ':';
            voices.set(v, voice_str);
        }
    }

    for (var v of voices.keys()) {
        var voice_str = voices.get(v);
        voice_str += '|]';
        voices.set(v, voice_str);
    }

    // Finally add all voice string to abc_string
    for (var v of voices.keys()) {
        abc_string += voices.get(v) + '\n';
    }

    // Only render for a certain maximum of moves/notes for performance and common sense.
    var notecount = moves.length * (loop ? 2 : 1);
    if (notecount > MAXABC) {
        $('#abc').html('Too long to score').css('height', '');
    } else {
        ABCJS.renderAbc("abc", abc_string, {
            add_classes: true,
            wrap: {
                minSpacing: 1,
                maxSpacing: 1,
                preferredMeasuresPerLine: 12
            },
            staffwidth: $('#abc').width()*0.9
        });

        // Color notes by disk
        if ($('#checkbox_colornotes').prop('checked')) {
            for (noteindex = 0; noteindex < disksequence.length; noteindex++) {
                var disk = disksequence[noteindex];
                var color = get_disk_color(disk, '100%', '50%');             
                var measure = Math.floor(noteindex / timesignature);
                var note = noteindex % timesignature; 

                $('.abcjs-mm' + measure + '.abcjs-n' + note).css('fill', color);
            }
        }
    };

    // Show notation string for copy/paste.
    $('#textarea_abc_string').val(abc_string);
}

function set_playing(val) {
    // Update the playing-flag and the text on the play/stop-Button
    playing = val;
    $('.button_play').text(playing ? 'Stop' : 'Play');
}

function play_move() {
    // Auto-play a single precalculated move and find out what the next
    // move will be.

    var source = moves[current_move][0];
    var target = moves[current_move][1];
    
    update_moves_label();
    
    if (reverse) {
        // Swap source and target.
        var tmp = source;
        source = target;
        target = tmp;
    }

    // console.log('play_move(' + current_move + ') from #' + source + ' to #' + target);

    // If we looped in the last step we now need to instantly put back all
    // disks on peg #0.
    if (reset_before_next_move) {
        $('.disk').remove();
        create_disks();
        reset_before_next_move = false;
    }

    // Make visual move:
    // Get the top disk from the source peg.
    var disk = $('#peg' + source + ' div.disk').first();
    // And drop it onto the target peg.
    $('#peg' + target).prepend(disk);

    // Playback of selected instrument.
    remove_all_glow();

    // Show glow on the peg-base where the <select>s are.
    $('#instrument' + target).addClass('glower_active');
    $('#sample' + target).addClass('glower_active');

    // Show glow on the keyboards in the sample library.
    $('[data-instrument="' + selected_samples[target][0] + '"][data-sample-id="' + selected_samples[target][1] + '"]').addClass('glower_active');  

    if (glow_deactivation_timer) {
        clearTimeout(glow_deactivation_timer);
    }
    glow_deactivation_timer = setTimeout(remove_all_glow, 1000);

    // Play sound.
    play_sample(selected_samples[target][0], selected_samples[target][1]);
    
    // Highlight current notation or rest in the abc notation.
    var abcmeasure = Math.floor(abc_note_index / timesignature);
    var abcnote = abc_note_index % timesignature; 

    $('.abcjs-note').removeClass('current_note');
    $('.abcjs-rest').removeClass('current_note');
    $('.abcjs-mm' + abcmeasure + '.abcjs-n' + abcnote).addClass('current_note');

    // Overall notes played. This only resets on a new start.
    note_play_count++;
    
    // What note within the abc-notation is played next? This only resets after a full loop.
    abc_note_index++;

    // Figure out next move to play. This is complicated by the loop- and addreverse-options.
    if (!reverse) {
        // Playing forward.
        current_move = current_move + 1;
        if (current_move == moves.length) {
            // Reached the end. Do we want to play in reverse next?
            if (addreverse) {
                // Yes. Set reverse flag and adjust current_move.
                reverse = true;
                current_move = moves.length-1;
            } else {
                // No. Don't reverse.
                current_move = 0;
                abc_note_index = 0;
                reset_before_next_move = true;
            
                // Loop?
                if (!loop) {
                    // No. Stop. But we are ready to restart on the next click on play.
                    reached_end = true;
                    set_playing(false);
                    
                    if (recording) {
                        record_toggle();
                    }
                } 
            }
        }
    } else {
        // Playing in reverse.
        current_move = (current_move-1);
        if (current_move == -1) {
            // Back at the start. Are we looping?           
            reverse = false;
            current_move = 0;
            abc_note_index = 0;

            if (!loop) {
                // Not looping. Stop. But we are ready to start playing again.
                reached_end = true;
                set_playing(false);
                
                if (recording) {
                    record_toggle();
                }
            }
        }
    } 
    
    // Still playing? Schedule next move.
    if (playing) {
        play_move_timer = setTimeout(play_move, (60/bpm*1000));
    } else {
        play_move_timer = null;
    }
}

function step() {
    // Play a single move.

    // console.log('step()');

    // When single-stepping avoid inadvertent looping if not selected.
    if (!reached_end) {
        if (play_move_timer) {
            clearTimeout(play_move_timer);
            play_move_timer = null;
        }
        set_playing(false);

        play_move();

        console.log('disabled');
        console.log(reached_end);
        $('.button_step').prop('disabled', reached_end);
    }
}

function play() {
    // console.log('play()');

    reached_end = false;
    $('.button_step').prop('disabled', false);

    if (playing) {
        // Pause
        if (play_move_timer) {
            clearTimeout(play_move_timer);
            play_move_timer = null;
        }
        set_playing(false);
    } else {
        // Play
        set_playing(true);
        if (!play_move_timer) {
            play_move();
        }
    }
}

function reset() {
    // console.log('reset()');
                
    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);
    
    init_board();
}

function init_board() {
    // console.log('init_board()');
    
    hanoi(pegs, disks);
    update_moves_label();

    // Update Screen to initial conditions
    
    // Clear all pegs and disks. Also re-selects all the samples.
    create_pegs();
    create_disks();

    current_move = 0;
    note_play_count = 0;
    abc_note_index = 0;

    reached_end = false;
    $('.button_step').prop('disabled', false);

    abc_render();
}

function custom_sample_load(e) {
    // User has selected a file to upload as custom sample. Load and decode asynchronously
    // and when finished play it once.

    // console.log('custom_sample_load()');

    custom_sample_file = e.target.files[0];
    custom_sample_file.arrayBuffer().then(function(arrayBuffer) {
        audio_context.decodeAudioData(arrayBuffer).then(function(audioBuffer) {
            custom_sample_buffer = audioBuffer;
            update_ui();
            custom_sample_play();
        })
    });
};

function custom_sample_play() {
    // console.log('custom_sample_play()');

    var source = audio_context.createBufferSource();
    source.buffer = custom_sample_buffer;
    source.connect(gain_node);
    source.start();
}

function custom_sample_add() {
    // Add a preloaded custom sample to the sample library.

    // console.log('custom_sample_add()');
    
    if (!sample_catalog.has(INST_CUSTOM)) {
        sample_catalog.set(INST_CUSTOM, []);
        $('#sample_library').after('<div class="uirow" id="sample_library_custom"><label class="fieldname">Custom</label></div>');
    }

    var samples = sample_catalog.get(INST_CUSTOM);
    var sample_id = custom_sample_file.name;

    var abcnote = $('#text_custom_sample_note').val();
    // No abc-note specified. Pick one that has not been used for custom samples.
    if (!abcnote) {
        abcnote = abc_notes[samples.length];
    }

    // Chop off file extension
    var p = sample_id.lastIndexOf('.');
    if (p != -1) {
        sample_id = sample_id.substr(0, p);
    }

    // Check wether the sample already exists (by file name). If so update in the library,
    // the user may have different files uploaded under the same name. Or changed other
    // settings like the ABC note associated.
    var newsample = true;
    for (var sample_index = 0; sample_index < samples.length; sample_index++) {
        if (samples[sample_index][SAMPLE_ID] == sample_id) {
            // Sample exists. Update information.
            samples[sample_index][SAMPLE_ABC_NOTE] = abcnote;
            samples[sample_index][SAMPLE_BUFFER] = custom_sample_buffer;
        } 
    }

    if (newsample) {
        // New sample. Append to list and update controls.
        samples.push([sample_id, custom_sample_file.name, abcnote, custom_sample_buffer]);
    
        var btnid = 'Custom-' + sample_id.replace(/\./g,'_');
        $('#sample_library_custom').append('<button class="button_sample_library glower" id="' + btnid + '" data-instrument="Custom" data-sample-id="' + sample_id + '">' + samples[sample_index][SAMPLE_URL] + '</button>');                    
        
        $('#' + btnid)
            .click(play_from_sample_library)
            .prop('draggable', 'true')
            .on('dragstart', sample_dragstart)
            .on('dragend', sample_dragend);
   
        for (var peg = 0 ; peg<pegs ; peg++) {
            $('#instrument' + peg).append('<option value="' + INST_CUSTOM + '">' + INST_CUSTOM + '</option>');
            update_note_options(peg);
        }
    }

    // Clear temporary data and file upload field.
    custom_sample_file = null;
    custom_sample_buffer = null;
    $('#file_custom_sample').val('');
    
    update_ui();
}

function record_toggle() {
    // Start or stop recording. See record.js.

    // console.log('record_toggle()');

    if (!recording) {
        // Start recording
        $('#audio_record_playback').remove();
        $('#button_record_download').remove();
        $('#div_record').append('<label id="label_record">Recording audio...</label>');
        
        // console.log('Now recording');
        recorder.record();
        recording = true;

        update_ui();
    } else {
        // Stop recording.
        $('#label_record').remove();

        recorder.stop();
        recorder.exportWAV(function(blob) {
            var url = URL.createObjectURL(blob);
            var name = 'Towers_of_Annoy_' + moment().format('YYYY-MM-DD-hh-mm-ss') + '.wav';

            // Load recorded data into a new <audio>-element for instant playback. Also add a download link.
            $('#div_record').append('<audio id="audio_record_playback" controls="true" src="' + url + '"></audio><a href="' + url + '" download="' + name +'"><button id="button_record_download">Download</button></a>');

            // Prepare recorder for new recording.
            recorder.clear();
            recording = false;
            
            update_ui();
        });
        
    }
}

function analyser_draw() {
    // Fetch the frequency-domain data from the analysernode and render a pretty graph.
    
    analyser_node.getByteFrequencyData(fft_array);
    
    var w = $('#analyser').width();
    var h = $('#analyser').height();

    analyser_context.canvas.width  = w;
    analyser_context.canvas.height = h;

    analyser_context.fillStyle = 'rgb(200, 200, 200)';
    analyser_context.fillRect(0, 0, w, h);
    
    // Center/Zero line.
    analyser_context.lineWidth = 1;
    analyser_context.strokeStyle = "white";
    analyser_context.beginPath();
    analyser_context.moveTo(0, h/2);
    analyser_context.lineTo(w, h/2);
    analyser_context.stroke(); 

    var dx = Math.min(15, w / fft_array.length);
    var m = dx/10;
    var x = (w - (dx * fft_array.length)) / 2;
    
    // Bar graph
    analyser_context.fillStyle = 'rgb(230,230,230)';
    for(var i = 0; i < fft_array.length; i++) {
        var bar_height = fft_array[i] / 255.0 * h; // 0..255 mapped to 0..canvas-height

        analyser_context.fillRect(x+m, (h - bar_height)/2, dx-2*m, bar_height);

        x += dx;
    }

    requestAnimationFrame(analyser_draw);
}

function sample_dragstart(e) {
    // User starts dragging a sample from the library.

    // console.log('dragstart()');
    
    var t = parent_with_id(e.target);
    $(t).addClass('dragging');
    
    sample_being_dragged = {
        "instrument": $("#" + t.id).data('instrument'),
        "sample_id":  $("#" + t.id).data('sample-id')
    }
}

function sample_dragend(e) {
    // User finished dragging a sample from the library.
    
    // console.log('dragend()');    
    
    var t = parent_with_id(e.target);
    $(t).removeClass('dragging');

    sample_being_dragged = null;
}

function sample_dragover(e) {
    // Sample is being dragged ofer a dropzone. Make the target glow.

    // console.log('dragover()');
    
    e.preventDefault();  
    e.stopPropagation();

    $(e.target).closest('.peg_base').find('.glower').addClass('glower_active');
} 

function sample_dragleave(e) {
    // Sample is being dragged off a dropzone. Remove the target glow.

    // console.log('dragleave()');
    
    e.preventDefault();  
    e.stopPropagation();

    $(e.target).closest('.peg_base').find('.glower').removeClass('glower_active');
}

function sample_drop(e) {
    // Sample is dropped on a dropzone.

    e.preventDefault();  
    e.stopPropagation();

    if (sample_being_dragged) {
        
        // What peg are we dropped on? Extract from the element-ID. 
        var peg = $(e.target).closest('.peg_base')[0].id.substr('peg_base'.length);

        // console.log('drop(\'' + sample_being_dragged.instrument + '\',\'' + sample_being_dragged.sample_id + '\') on peg #' + peg);

        // Extract the data for the sample being dragged and update the current selection.
        selected_samples[peg][0] = sample_being_dragged.instrument;
        selected_samples[peg][1] = sample_being_dragged.sample_id;
        
        // Update the <selects> on the UI, render notation and play the dropped sample once. 
        select_sample(peg);
        abc_render();
        play_sample(selected_samples[peg][0], selected_samples[peg][1]);

        $('[data-instrument="' + selected_samples[peg][0] + '"][data-sample-id="' + selected_samples[peg][1] + '"]').addClass('glower_active');
        if (glow_deactivation_timer) {
            clearTimeout(glow_deactivation_timer);
        }
        glow_deactivation_timer = setTimeout(remove_all_glow, 1000);

        sample_being_dragged = null;
    }
}

$(document).ready(function() {
    // Main entry point.

    // Set up Audio-API objects and nodes.
    window.AudioContext = window.AudioContext  || window.webkitAudioContext;
    audio_context = new AudioContext();
    
    analyser_node = audio_context.createAnalyser();
    analyser_node.fftSize = 128;
    fft_array = new Uint8Array(analyser_node.frequencyBinCount);

    gain_node = audio_context.createGain();
    compressor_node = audio_context.createDynamicsCompressor();

    gain_node.connect(compressor_node);
    compressor_node.connect(analyser_node);
    analyser_node.connect(audio_context.destination);

    // Set up recorder.js.
    recorder = new Recorder(analyser_node);

    // Set up preview controls for all the samples in the library.
    for (var instrument of sample_catalog.keys()) {
        var id = 'sample_library_' + instrument.replace(' ', '_');
        var samples = sample_catalog.get(instrument);
        var keyboard = ((instrument != INST_CUSTOM) && (instrument != 'Percussion'));
        
        $('#sample_library').after(
            '<div class="uirow"><label class="fieldname">' + instrument + '</label></div>' + 
            '<div class="uirow" id="' + id + '"></div>');
        $('#' + id).append('<div class="samples' + (keyboard ? ' keyboard"' : '') + '"></div>');
        
        for(var sample_index = 0; sample_index < samples.length ; sample_index++) {
            var key = samples[sample_index][SAMPLE_ID].substr(0,1).toLowerCase() + ((samples[sample_index][SAMPLE_ID].indexOf('\u266d') != -1) ? '_flat' : '');
            
            $(('#' + id + ' .samples')).append('<button class="button_sample_library glower' + 
                (keyboard ? ' key ' + key : '') + 
                (keyboard ? ((samples[sample_index][SAMPLE_ID].indexOf('\u266d') != -1) ? ' black' : ' white') : '') + 
                '" id="' + instrument.replace(' ', '_') + '-' + samples[sample_index][SAMPLE_ID] + '" data-instrument="' + instrument + '" data-sample-id="' + samples[sample_index][SAMPLE_ID] + '">' + samples[sample_index][SAMPLE_ID] + '</button>');            
        }
    }

    $('.button_sample_library')
        .click(play_from_sample_library)
        .prop('draggable', 'true')
        .on('dragstart', sample_dragstart)
        .on('dragend', sample_dragend);
   
    // Set up default sounds. We simply use the Percussion-instrument samples in 
    // order of definition in the instrument-map.
    var percussion_instruments = sample_catalog.get('Percussion');
    for (var instrument_index = 0 ; instrument_index < percussion_instruments.length ; instrument_index++) {
        selected_samples.push(['Percussion', percussion_instruments[instrument_index][SAMPLE_ID]]);
    }

    while (selected_samples.length <= $('#slider_pegs').prop('max')) {
        selected_samples.push(['silence', 'silence']);
    }

    // Overwrite initial UI settings with parameters from the URL if specified.
    parse_url();

    update_ui();
    init_board();
    
    // Preload default samples.
    new BufferLoader(
        function() {
            console.log('default samples loaded');
    }
    ).load_all();

    // Wire UI control events.
    $('#slider_pegs').on('input',          update_ui);
    $('#slider_disks').on('input',         update_ui);
    $('#slider_volume').on('input',        update_ui);
    $('#slider_bpm').on('input',           update_ui);
    $('#slider_timesignature').on('input', update_ui);
    
    $('#checkbox_loop').on('change',       update_ui);
    $('#checkbox_addreverse').on('change', update_ui);
    $('#checkbox_colornotes').on('change', update_ui);
    $('#checkbox_darkmode').on('change',   update_ui);

    $('.button_step').click(step);
    $('.button_play').click(play);
    $('.button_reset').click(reset);

    $('#file_custom_sample').on('change', custom_sample_load);
    $('#button_custom_sample_library').click(custom_sample_play);
    $('#button_custom_sample_add').click(custom_sample_add);

    $('#button_record').click(record_toggle);

    // Prepare the spectrum analyser canvas.
    analyser_canvas = $('#analyser');
    analyser_context = analyser_canvas[0].getContext("2d");

    // Clear file upload field.
    $('#file_custom_sample').val('');
    
    // Initialize the visualization loop.
    analyser_draw();
    update_ui();

    // Annoy me!
})

</script>

</html>