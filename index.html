<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <title>Towers of Annoy</title>
        <script src="./jquery-3.6.0.min.js"></script>	
        <script src="./BufferLoader.js"></script>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div id='toa'>
            <h1>Towers of Annoy</h1>
            <p>Play <em>n</em>-peg Towers of Hanoi with <em>k</em> disks.</p>
            <p>This implements the Frame-Stewart-Algorithm to create a solution and plays it back to the user. Whenever a disk is put 
                optionally trigger a musical sound.</p>                    
            <div id="board">                
            </div>
            <div id="board_base">                
            </div>
            <div id="controls">
                <div class="uirow">
                    <label class="fieldname">Pegs:</label>
                    <input type="range" min="3" max="8" value="3" class="slider" id="slider_pegs">
                    <label class="slidervalue" id="label_pegs"></label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Disks:</label>
                    <input type="range" min="1" max="15" value="3" class="slider" id="slider_disks">
                    <label class="slidervalue" id="label_disks"></label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Audio-Volume:</label>
                    <input type="range" min="1" max="1000" value="700" class="slider" id="slider_volume">
                    <label class="slidervalue" id="label_volume"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">Audio-BPM:</label>
                    <input type="range" min="10" max="180" value="60" class="slider" id="slider_bpm">
                    <label class="slidervalue" id="label_bpm"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">Playback:</label>
                    <input type="checkbox" id="checkbox_addreverse" name="addreverse" unchecked>Add reverse</input>
                    <input type="checkbox" id="checkbox_loop" name="loop" unchecked>Loop</input>
                    <button id="button_step">Step</button>
                    <button id="button_play">Play</button>
                    <button id="button_reset">Reset</button>
                    <label class="slidervalue" id="label_moves"></label>
                </div>               
            </div>
        </div>
    </body>

<script type="module">

// Read the GET URL variables and return them as an associative array.
function getUrlVars() {
    var vars = {}

    if (window.location.href.indexOf('?') != -1) { 
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for (var i = 0; i < hashes.length; i++)
        {
            var hash = hashes[i].split('=');
            vars[hash[0]] = decodeURI(hash[1]);
        }
    }

    return vars;
}

var updatingUI;

function set_playing(val) {
    playing = val;
    $('#button_play').text(playing ? 'Stop' : 'Play');
}

function update_ui(e) {
    // don't recurse here if we internally update UI controls.
    if (updatingUI) { return };
    updatingUI = true;

    console.log('update_ui()');

    var v;
    
    pegs = parseInt($('#slider_pegs').val());
    $('#label_pegs').text(pegs);

    disks = parseInt($('#slider_disks').val());
    $('#label_disks').text(disks);

    v = parseInt($('#slider_volume').val())/1000;
    $('#label_volume').text(Math.floor(v*100) + "%");
    if (gain_node) {
        gain_node.gain.value = Math.pow(v, 2);
    }

    bpm = parseInt($('#slider_bpm').val());
    $('#label_bpm').text(bpm);
    
    loop = ($('#checkbox_loop').prop('checked'));
    addreverse = ($('#checkbox_addreverse').prop('checked'));

    // Stop playback if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        reset();
    } 

    // Reinitialize board if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        init_board();
    } 

    updatingUI = false;
}

const available_samples = [
    'samples/kick-808.wav',
    'samples/clap-808.wav',
    'samples/hihat-808.wav',
    'samples/snare-808.wav',
    'samples/openhat-808.wav',
    'samples/kick-plain.wav',
    'samples/perc-808.wav',
    'samples/tom-808.wav'
];

var pegs;
var disks;
var bpm;
var loop;
var addreverse;

var analyser_node;
var compressor_node;
var gain_node;
var saved_instruments = [];

var fft_array;
var audio_context;
var instrument_buffers;

var moves = [];
var current_move = 0;
var playing = false;
var reverse = false;
var play_move_timer;
var glow_deactivation_timer;
var reset_before_next_move = false;

// Calculate the moves for a given game of the Towers of Hanoi. Moves 
// are pushed onto the moves-array in format [source, target].
function Hanoi(pegs, disks) {
    console.log('Hanoi(' + pegs + ',' + disks + ')');

    var board = [];

    // Represent the board as a string for logging/debugging. 
    function boardtostr() {

        var boardstr = '';

        for(var peg = 0 ; peg<pegs ; peg++) {
            boardstr += '#' + peg + ':['; 
            boardstr += board[peg].join(', ') + '] ';            
        }
        
        return boardstr;
    }

    // Process a move from source to target. This updates the internal board representation
    // for logging and debugging. Also push the move to the global moves-array.
    function move(source, target) {    
        var disk = board[source].pop();
        board[target].push(disk);
    
        moves.push([source, target]);
        // console.log('#' + moves.length + ': From #' + source + ' to #' + target + '  -  ' + boardtostr());
    }   
    // Main bit: Implements the Frame-Stewart-algorithm.
    function solve(level, disks, source, dest, intermediates) {

        // console.log(level + 'solve(' + disks + ', ' + source + ', ' + dest + ', [' + intermediates.join(',') + '])');

        if (disks == 1) {
            move(source, dest);
        } else {
            var p;

            // Copy intermediates for recursion:
            intermediates = intermediates.slice();

            // Pick a number of disks to move.
            if (intermediates.length >= 2) {
                p = Math.floor(disks/2);
            } else {
                p = disks - 1;
            }

            // Move top p disks from source to one intermediate
            var intermediate = intermediates.pop();
            intermediates.push(dest);
            solve(level + '   ', p, source, intermediate, intermediates);

            // Move the rest of the disks from source to dest
            intermediates.pop();
            solve(level + '   ', disks - p, source, dest, intermediates);

            // Move p disks from chosen intermediate to the final peg
            intermediates.push(source);
            solve(level + '   ', p, intermediate, dest, intermediates);
        }
    }

    // Reset moves array.
    moves = []
    current_move = 0;
    reverse = false;

    // Build initial board representation: Array of pegs each with an array 
    // of disk-numbers on them.
    for(var peg = 0 ; peg<pegs ; peg++) {
        board.push([]);
    }

    // Put all the disks on the first peg.
    for(var disksize = disks ; disksize>0 ; disksize--) {
        board[0].push(disksize);
    }

    // Create an array of all the available intermediate pegs.
    var available_intermediates = [];
    for(var peg = 1 ; peg<pegs-1 ; peg++) {
        available_intermediates.push(peg);
    }

    console.log('Start: ' + boardtostr());

    solve('', disks, /* source */ 0, /* target */ pegs-1, available_intermediates);
    
    console.log('Solved in ' + moves.length + ' moves.');
}

function get_disk_color(disk)
{
    // Map the disk 1..n to a HSL hue between 240 and 0.
    var minHue = 240, maxHue=0;
    var curPercent = (disk-1) / (disks-1);
    var colString = "hsl(" + ((curPercent * (maxHue-minHue) ) + minHue) + ",100%,50%)";
    return colString;
}

function create_pegs() {
    // Save the selected instruments for all current pegs.
    console.log(saved_instruments);

    var oldpegs = $('.instrument_select').length;

    for (var peg = 0; peg<oldpegs ; peg++) {
        if (peg >= saved_instruments.length) {
            saved_instruments.push(-1);
        } else {
            var instrument_id = $('#instrument' + peg).val();
            if (instrument_id) {
                saved_instruments[peg]=instrument_id;
            }
        }
    }

    console.log(saved_instruments);

    $('#board').empty();
    $('#board_base').empty();
    
    // Create pegs
    for (var peg = 0; peg<pegs ; peg++) {
        $('#board').append('<div class="peg" id="peg' + peg + '"></div>');

        $('#board_base').append('<div class="peg_base" id="peg_base' + peg + '"><select class="instrument_select glower" id="instrument' + peg + '"></select></div>');
        $('#instrument' + peg).append('<option value="-1">Silent</option>');
        for(var sampleindex = 0; sampleindex<available_samples.length; sampleindex++) {
            $('#instrument' + peg).append('<option value="' + sampleindex + '">' + available_samples[sampleindex].substring('samples/'.length) + '</option>');
        }

        // Re-select previously selected instrument.
        if (peg < saved_instruments.length) {
            $('#instrument' + peg).val(saved_instruments[peg]);
        }
    }
}    

function create_disks() {
    // Create all required disks as DIV on peg#
    for(var disk = 1 ; disk<=disks ; disk++) {
        console.log('create disk ' + disk);
        $('#peg0').append('<div class="disk" id="disk' + disk + '"><div class="disk_body"></div></div>');
        $('#disk' + disk + ' .disk_body').width(disk + 'em').css('background',get_disk_color(disk)); 
    }

    // Resize board.
    $('#board').css('height', (3+disks) + 'em');
}

function update_moves_label() {
    $('#label_moves').text('move ' + (current_move+1) +' of ' + moves.length);
}

function remove_all_glow() {
    $('.instrument_select').removeClass('glower_active');
    if (glow_deactivation_timer) {
        clearTimeout(glow_deactivation_timer);
        glow_deactivation_timer = 0;
    }
}
    
function play_move() {
    console.log('play_move(' + current_move + ')');

    var source = moves[current_move][0];
    var target = moves[current_move][1];
    
    update_moves_label();
    
    if (reverse) {
        // Swap source and target.
        var tmp = source;
        source = target;
        target = tmp;
    }

    console.log('play_move(' + current_move + ') from #' + source + ' to #' + target);

    // If we looped in the last step we now need to intantly put back all
    // disks on peg 0.
    if (reset_before_next_move) {
        $('.disk').remove();
        create_disks();
        reset_before_next_move = false;
    }

    // Get the top disk from the source peg.
    var disk = $('#peg' + source + ' div.disk').first();
    // And drop it onto the target peg.
    $('#peg' + target).prepend(disk);

    remove_all_glow();

    // Start playback of selected instrument
    var selected_instrument = $('#instrument' + target).val();
    if (selected_instrument != -1) {
        $('#instrument' + target).addClass('glower_active');
        glow_deactivation_timer = setTimeout(remove_all_glow, 1000);

        var source = audio_context.createBufferSource();
        source.buffer = instrument_buffers[selected_instrument];
        source.connect(gain_node);
        source.start();
    }

    // Figure out next move to play. This is complicated by the loop- and addreverse-options.
    if (!reverse) {
        // Playing forward.
        current_move = current_move + 1;
        if (current_move == moves.length) {
            // Reached the end. Do we want to play in reverse next?
            if (addreverse) {
                // Yes. Set reverse flag and adjust current_move.
                reverse = true;
                current_move = moves.length-1;
            } else {
                current_move = 0;
                reset_before_next_move = true;
                
                // Don't reverse. Loop?
                if (!loop) {
                    // No. Stop. But we are ready to restart on the next click on play.
                    set_playing(false);              
                } 
            }
        }
    } else {
        // Playing in reverse.
        current_move = (current_move-1);
        if (current_move == -1) {
            // Back at the start. Are we looping?
            
            reverse = false;
            current_move = 0;
            if (!loop) {
                // Not looping. Stop. But we are ready to start playing again.
                set_playing(false);
            }
        }
    } 
    
    // Still playing? Schedule next move.
    if (playing) {
        play_move_timer = setTimeout(play_move, (60/bpm/4)*1000);
    } else {
        play_move_timer = null;
    }
}

function step() {
    console.log('step()');

    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);

    play_move();
}

function play() {
    console.log('play()');

    if (playing) {
        // Pause
        if (play_move_timer) {
            clearTimeout(play_move_timer);
            play_move_timer = null;
        }
        set_playing(false);
    } else {
        // Play
        set_playing(true);
        if (!play_move_timer) {
            play_move();
        }
    }
}

function reset() {
    console.log('reset()');

    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);
    
    init_board();
}

function init_board() {
    console.log('init_board()');
    
    Hanoi(pegs, disks);
    update_moves_label();

    // Update Screen to initial conditions
    
    // Clear all pegs and disks
    create_pegs();
    create_disks();
}

$(document).ready(function() {

    // window.AudioContext = window.AudioContext  || window.webkitAudioContext;
    audio_context = new AudioContext();
    
    analyser_node = audio_context.createAnalyser();
    analyser_node.fftSize = 128;
    fft_array = new Uint8Array(analyser_node.frequencyBinCount);

    gain_node = audio_context.createGain();
    // gain_node.gain.value = Math.pow(volumeSlider.value/1000, 2);
    
    compressor_node = audio_context.createDynamicsCompressor();

    gain_node.connect(compressor_node);
    compressor_node.connect(analyser_node);
    analyser_node.connect(audio_context.destination);

    new BufferLoader(
        audio_context,
        available_samples,
        function(data) {
            console.log('Samples loaded.');

            instrument_buffers = data;

            // Default instruments in order of samples. 
            for(var instrument = 0 ; instrument<available_samples.length ; instrument++) {
                saved_instruments.push(instrument);
            }

            update_ui();
            init_board();            
        }
    ).load();

    $('#slider_pegs').on("input change", update_ui);
    $('#slider_disks').on("input change", update_ui);
    $('#slider_volume').on("input change", update_ui);
    $('#slider_bpm').on("input change", update_ui);
    
    $('#checkbox_loop').on("change", update_ui);
    $('#checkbox_addreverse').on("change", update_ui);

    $( "#button_step" ).click(step);
    $( "#button_play" ).click(play);
    $( "#button_reset" ).click(reset);

    var urlvars = getUrlVars();

    update_ui();
})

</script>

</html>

