<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
        <link rel="icon" href="/favicon.png" type="image/png">
        <title>Towers of Annoy</title>
        <script src="./jquery-3.6.0.min.js"></script>	
        <script src="./abcjs-basic-min.js" type="text/javascript"></script>
        <script src="./recorder.js"></script>
        <script src="./moment.js"></script>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <div id='toa'>
            <h1>Towers of Annoy</h1>
            <div class="uirow">
                <button class="button_step" accesskey="s">Step</button>
                <button class="button_play" accesskey="p">Play</button>
                <button class="button_reset">Reset</button>
                <label class="slidervalue label_moves" id="label_moves1"></label>
                <label class="slidervalue" id="label_moves">&nbsp;&nbsp;<em>(For more controls see below)</em></label>
            </div>
            <div id="board">                
            </div>
            <div id="board_base">                
            </div>
            <div id="analyser_container">
                <canvas id="analyser"></canvas>
            </div>
            <div id="abc"></div>
            <div id="controls">
                <div class="uirow sectiontitle">
                    <label class="fieldname">Game</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Number of pegs</label>
                    <input type="range" min="3" max="8" value="3" class="slider" id="slider_pegs">
                    <label class="slidervalue" id="label_pegs"></label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Number of disks</label>
                    <input type="range" min="1" max="15" value="3" class="slider" id="slider_disks">
                    <label class="slidervalue" id="label_disks"></label>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Notation</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Time signature</label>
                    <input type="range" min="1" max="12" value="4" class="slider" id="slider_timesignature">
                    <label class="slidervalue" id="label_timesignature"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">General appearance</label>
                    <input type="checkbox" id="checkbox_colornotes" name="colornotes" unchecked>Color note by disk</input>
                </div>
                <div class="uirow">
                    <label class="fieldname">abc notation string&nbsp;<a href="http://abcnotation.com/wiki/abc:standard:v2.1" target="_blank">[?]</a></label>
                    <textarea id="textarea_abc_string" readonly></textarea>
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Audio</label>
                </div>
                <div class="uirow">
                    <label class="fieldname">Volume</label>
                    <input type="range" min="1" max="1000" value="700" class="slider" id="slider_volume">
                    <label class="slidervalue" id="label_volume"></label>
                </div>             
                <div class="uirow">
                    <label class="fieldname">BPM</label>
                    <input type="range" min="10" max="480" value="240" class="slider" id="slider_bpm">
                    <label class="slidervalue" id="label_bpm"></label>
                </div>             
                <div class="uirow sectiontitle">
                    <label class="fieldname">Playback</label>
                </div>
                <div class="uirow">
                    <input type="checkbox" id="checkbox_addreverse" name="addreverse" unchecked>Add reverse</input>
                    <input type="checkbox" id="checkbox_loop" name="loop" unchecked>Loop</input>
                </div>
                <div class="uirow">
                    <button class="button_step" accesskey="s">Step</button>
                    <button class="button_play" accesskey="p">Play</button>
                    <button class="button_reset">Reset</button>
                    <label class="slidervalue label_moves" id="label_moves2"></label>
                </div>
                <div class="uirow" id="div_record">
                    <button id="button_record" accesskey="s">Start Recording</button>                    
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Instrument preview:</label>
                </div>
                <div class="uirow">
                    <div id="preview_buttons"></div>                    
                </div>
                <div class="uirow sectiontitle">
                    <label class="fieldname">Upload custom sample</label>
                </div>
                <div class="uirow">
                    <input id="file_custom_instrument" type="file" accept="audio/*"/>
                    <label>abc note&nbsp;<a href="http://abcnotation.com/wiki/abc:standard:v2.1#pitch" target="_blank">[?]</a>&nbsp;<input id="text_custom_instrument_note" type="text" maxlength="4" style="width: 3em;"/>
                    <button id="button_custom_sample_preview" disabled>Preview</button>
                    <button id="button_custom_sample_add" disabled>Add</button>
                </div>               
            </div>
        </div>
    </body>

<script type="module">

// Read the GET URL variables and return them as an associative array.
function getUrlVars() {
    var vars = {}

    if (window.location.href.indexOf('?') != -1) { 
        var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
        for (var i = 0; i < hashes.length; i++)
        {
            var hash = hashes[i].split('=');
            vars[hash[0]] = decodeURI(hash[1]);
        }
    }

    return vars;
}

var updatingUI;

function set_playing(val) {
    playing = val;
    $('.button_play').text(playing ? 'Stop' : 'Play');
}

function update_ui(e) {
    // don't recurse here if we internally update UI controls.
    if (updatingUI) { return };
    updatingUI = true;

    // console.log('update_ui()');

    var v;
    
    pegs = parseInt($('#slider_pegs').val());
    $('#label_pegs').text(pegs);

    disks = parseInt($('#slider_disks').val());
    $('#label_disks').text(disks);

    v = parseInt($('#slider_volume').val())/1000;
    $('#label_volume').text(Math.floor(v*100) + "%");
    if (gain_node) {
        gain_node.gain.value = Math.pow(v, 2);
    }

    bpm = parseInt($('#slider_bpm').val());
    $('#label_bpm').text(bpm);
    
    loop = ($('#checkbox_loop').prop('checked'));
    addreverse = ($('#checkbox_addreverse').prop('checked'));
    
    timesignature = parseInt($('#slider_timesignature').val());
    $('#label_timesignature').text(timesignature + '/4');
    
    // Stop playback if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        reset();
    } 

    // Reinitialize board if anything relevant has changed.
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks') 
    )) {
        init_board();
    } 

    // Rerender notation
    if (e && (false
        || (e.target.id=='slider_pegs') 
        || (e.target.id=='slider_disks')
        || (e.target.id=='checkbox_loop')
        || (e.target.id=='checkbox_addreverse')
        || (e.target.id=='checkbox_colornotes')
        || (e.target.id=='slider_timesignature')
    )) {
        abc_render();
    } 
    
    $('#button_custom_sample_preview').prop('disabled', !(custom_instrument_buffer));
    $('#button_custom_sample_add').prop('disabled', !(custom_instrument_buffer));

    if (recording) {
        $('#button_record').html('Stop recording');
    } else {
        $('#button_record').html('Start recording');
    }

    updatingUI = false;
}

// List of note to use in abc-Notation. We need one per instrument.
const abcnotes = ['E', 'F', 'G', 'A', 'B', 'c\'', 'd\'', 'e\'', 'f\'' ,'g\'', 'a\'', 'b\''];

// List of inbuilt available samples.
// Index 0 - Filename/URL
// Index 1 - Note to use in abc notation. Blank for automatic allocation/rhythm notation.
// Index 2 - Audiobuffer for playback.
const INST_NAME = 0;
const INST_NOTE = 1;
const INST_BUFFER = 2;
const INST_SILENT = -1;

const instruments = [
    [ 'hihat-808.wav',   '', null ],
    [ 'clap-808.wav',    '', null ],
    [ 'kick-plain.wav',  '', null ],
    [ 'kick-808.wav',    '', null ],
    [ 'snare-808.wav',   '', null ],
    [ 'openhat-808.wav', '', null ],
    [ 'perc-808.wav',    '', null ],
    [ 'tom-808.wav',     '', null ]
];

var pegs;
var disks;
var bpm;
var timesignature;
var loop;
var addreverse;

var analyser_node;
var compressor_node;
var gain_node;
var saved_instruments = [];

var fft_array;
var analyser_canvas;
var analyser_context;
var audio_context;

var recorder;
var recording = false;

var moves = [];
var current_move = 0;
var note_play_count = 0;
var abc_note_index = 0;
var playing = false;
var reverse = false;
var play_move_timer;
var glow_deactivation_timer;
var reset_before_next_move = false;

var custom_instrument_file = null;
var custom_instrument_buffer = null;

const MAXABC = 1024;

function BufferLoader(callback) {
    this.onload = callback;
    this.load_count = 0;
}

// Buffer loader basics taken from http://www.html5rocks.com/en/tutorials/webaudio/intro/js/buffer-loader.js
// Load each instrument, decode the audio and put it into the slot in the instruments array. Fire a callback
// when all samples are loaded.
BufferLoader.prototype.load_instrument = function(index) {
    // Load buffer asynchronously
    var request = new XMLHttpRequest();
    request.open('GET', 'samples/' + instruments[index][INST_NAME], true);
    request.responseType = 'arraybuffer';

    var loader = this;

    request.onload = function() {
        // Asynchronously decode the audio file data in request.response
        audio_context.decodeAudioData(
            request.response,
            function(buffer) {
                if (!buffer) {
                    console.log('error decoding file data: ' + url);
                    return;
                }
                instruments[index][INST_BUFFER] = buffer;
            
                loader.load_count++;

                if (loader.load_count == instruments.length)
                    loader.onload(loader.buffer_list);
            },
            function(error) {
                console.log('decodeAudioData error');
            }
        );
    }

    request.onerror = function() {
        console.log('BufferLoader: XHR error');
    }

    request.send();
}

BufferLoader.prototype.load_all = function() {
    for (var i = 0; i < instruments.length; ++i) {
        this.load_instrument(i);
    }
}

// Calculate the moves for a given game of the Towers of Hanoi. Moves 
// are pushed onto the moves-array in format [source, target].
function Hanoi(pegs, disks) {
    console.log('Hanoi(' + pegs + ',' + disks + ')');

    var board = [];

    // Represent the board as a string for logging/debugging. 
    function boardtostr() {

        var boardstr = '';

        for(var peg = 0 ; peg<pegs ; peg++) {
            boardstr += '#' + peg + ':['; 
            boardstr += board[peg].join(', ') + '] ';            
        }
        
        return boardstr;
    }

    // Process a move from source to target. This updates the internal board representation
    // for logging and debugging. Also push the move to the global moves-array.
    function move(source, target) {    
        var disk = board[source].pop();
        board[target].push(disk);
    
        moves.push([source, target, disk]);
        // console.log('#' + moves.length + ': Disk ' + disk + ' + from #' + source + ' to #' + target + '  -  ' + boardtostr());
    }   
    // Main bit: Implements the Frame-Stewart-algorithm.
    function solve(level, disks, source, dest, intermediates) {

        // console.log(level + 'solve(' + disks + ', ' + source + ', ' + dest + ', [' + intermediates.join(',') + '])');

        if (disks == 1) {
            move(source, dest);
        } else {
            var p;

            // Copy intermediates for recursion:
            intermediates = intermediates.slice();

            // Pick a number of disks to move.
            if (intermediates.length >= 2) {
                p = Math.floor(disks/2);
            } else {
                p = disks - 1;
            }

            // Move top p disks from source to one intermediate
            var intermediate = intermediates.pop();
            intermediates.push(dest);
            solve(level + '   ', p, source, intermediate, intermediates);

            // Move the rest of the disks from source to dest
            intermediates.pop();
            solve(level + '   ', disks - p, source, dest, intermediates);

            // Move p disks from chosen intermediate to the final peg
            intermediates.push(source);
            solve(level + '   ', p, intermediate, dest, intermediates);
        }
    }

    // Reset moves array.
    moves = []
    current_move = 0;
    reverse = false;

    // Build initial board representation: Array of pegs each with an array 
    // of disk-numbers on them.
    for(var peg = 0 ; peg<pegs ; peg++) {
        board.push([]);
    }

    // Put all the disks on the first peg.
    for(var disksize = disks ; disksize>0 ; disksize--) {
        board[0].push(disksize);
    }

    // Create an array of all the available intermediate pegs.
    var available_intermediates = [];
    for(var peg = 1 ; peg<pegs-1 ; peg++) {
        available_intermediates.push(peg);
    }

    // console.log('Start: ' + boardtostr());

    solve('', disks, /* source */ 0, /* target */ pegs-1, available_intermediates);
    
    console.log('Solved in ' + moves.length + ' moves.');
}

function get_disk_color(disk)
{
    // Map the disk 0..disks-1 to a HSL hue between min_hue and max_hue.
    var min_hue = 240
    var max_hue = 0;
    
    var hue;
    if (disks == 1) {
        hue = min_hue;
    } else {
        hue = (disk - 1) / (disks - 1) * (max_hue - min_hue) + min_hue;
    }

    var colString = "hsl(" + hue + ",100%,50%)";
    
    return colString;
}

function create_pegs() {
    // Save the selected instruments for all current pegs.
    
    var oldpegs = $('.instrument_select').length;

    for (var peg = 0; peg<oldpegs ; peg++) {
        if (peg >= saved_instruments.length) {
            saved_instruments.push(-1);
        } else {
            var instrument_id = $('#instrument' + peg).val();
            if (instrument_id) {
                saved_instruments[peg]=instrument_id;
            }
        }
    }

    $('#board').empty();
    $('#board_base').empty();
    
    // Create pegs
    for (var peg = 0; peg<pegs ; peg++) {
        $('#board').append('<div class="peg" id="peg' + peg + '"></div>');

        $('#board_base').append('<div class="peg_base" id="peg_base' + peg + '"><select class="instrument_select glower" id="instrument' + peg + '"></select></div>');
        $('#instrument' + peg).append('<option value="' + INST_SILENT + '">Silent</option>');
        for(var instrument_index = 0; instrument_index < instruments.length; instrument_index++) {
            $('#instrument' + peg).append('<option value="' + instrument_index + '">' + instruments[instrument_index][INST_NAME] + '</option>');
        }

        // Re-select previously selected instrument.
        if (peg < saved_instruments.length) {
            $('#instrument' + peg).val(saved_instruments[peg]);
        }

        $('#instrument' + peg).on("change", play_select_instrument_preview);
    }
}    

function create_disks() {
    // Create all required disks as DIV on peg#
    for(var disk = 1 ; disk<=disks ; disk++) {
        $('#peg0').append('<div class="disk" id="disk' + disk + '"><div class="disk_body"></div></div>');
        $('#disk' + disk + ' .disk_body').width(disk + 'em').css('background', get_disk_color(disk)); 
    }

    // Resize board.
    $('#board').css('height', (3+disks) + 'em');
}

function update_moves_label() {
    $('.label_moves').text('move ' + (current_move+1) +' of ' + moves.length);
}

function remove_all_glow() {
    $('.instrument_select').removeClass('glower_active');
    if (glow_deactivation_timer) {
        clearTimeout(glow_deactivation_timer);
        glow_deactivation_timer = 0;
    }
}
    
function play_instrument(instrument) {
    if (instrument != INST_SILENT) {
        var source = audio_context.createBufferSource();
        source.buffer = instruments[instrument][INST_BUFFER];
        source.connect(gain_node);
        source.start();
    }
}

function play_select_instrument_preview(e) {
    if (e) {
        play_instrument($('#' + e.target.id).val());
        
        // Re-render the notation in case an instrument switched to or from "silent" so
        // we can show or hide rests.
        abc_render();
    }
}

function play_button_instrument_preview(e) {
    if (e) {
        play_instrument(e.target.id.substr('button_instrument_'.length))
    }
}

function abc_render() {
    $('#abc').empty();
    $('#textarea_abc_string').empty();

    // Create the abc-string for the current solution. Including reversal and looping.
    var abc_string =
        'L: 1/4\n' + 
        'M: ' + timesignature  + '/4\n' +
        'K: C style=x\n';
        
    if (loop) {
        abc_string += '|:';
    }    

    notecount = 0;
    var disksequence = [];
    
    for(var noteindex = 0 ; noteindex < moves.length; noteindex++) {
        
        // Record sequence of disks so we can color notes respectively. 
        disksequence.push(moves[noteindex][2]);
        
        // Add note or rest depending on the instrument selected.
        var selected_instrument = $('#instrument' + moves[noteindex][1]).val();
        if (selected_instrument == INST_SILENT) {
            abc_string += 'z '; // rest
        } else {
            var note = abcnotes[selected_instrument];
            abc_string += abcnotes[selected_instrument] + ' ';
        }
        
        notecount++;

        // Add bar line if we have finished a bar AND are not done with the whole piece.
        if ((reverse || (noteindex < moves.length-1)) && (notecount % timesignature) == 0) {
            abc_string += '|';
        }
    }

    if (addreverse) {
        for(var noteindex = moves.length-1 ; noteindex >= 0; noteindex--) {
        
            // Record sequence of disks so we can color notes respectively. 
            disksequence.push(moves[noteindex][2]);
        
            // Add note or rest depending on the instrument selected.
            var selected_instrument = $('#instrument' + moves[noteindex][0]).val();
            if (selected_instrument == INST_SILENT) {
                abc_string += 'z '; // rest
            } else {
                abc_string += abcnotes[selected_instrument] + ' ';
            }
        
            notecount++;

            // Add bar line if we have finished a bar AND are not done with the whole piece.
            if ((noteindex >= 0) && (notecount % timesignature == 0)) {
                abc_string += '|';
            }
        }
    }

    /*
    // Add rests to complete the final bar.
    while (notecount % timesignature) {
        abc_string += 'z ';
        notecount++;
    }
    */

    // Add final bar line.
    if (loop) {
        abc_string += ':';
    }

    abc_string += '|]';

    // Only render for a certain maximum of moves/notes for performance and common sense.
    var notecount = moves.length * (loop ? 2 : 1);
    if (notecount > MAXABC) {
        $('#abc').html('Too long to score').css('height', '');
    } else {
        ABCJS.renderAbc("abc", abc_string, {
            add_classes: true,
            wrap: {
                minSpacing: 1,
                maxSpacing: 1,
                preferredMeasuresPerLine: 12
            },
            staffwidth: $('#abc').width()*0.9
        });

        // Color notes by disk
        if ($('#checkbox_colornotes').prop('checked')) {
            for (noteindex = 0; noteindex < disksequence.length; noteindex++) {
                var disk = disksequence[noteindex];
                var color = get_disk_color(disk);             
                var measure = Math.floor(noteindex / timesignature);
                var note = noteindex % timesignature; 

                $('.abcjs-mm' + measure + '.abcjs-n' + note).css('fill', color);
            }
        }
    };

    $('#textarea_abc_string').val(abc_string);
}

function play_move() {
    
    var source = moves[current_move][0];
    var target = moves[current_move][1];
    
    update_moves_label();
    
    if (reverse) {
        // Swap source and target.
        var tmp = source;
        source = target;
        target = tmp;
    }

    // console.log('play_move(' + current_move + ') from #' + source + ' to #' + target);

    // If we looped in the last step we now need to intantly put back all
    // disks on peg 0.
    if (reset_before_next_move) {
        $('.disk').remove();
        create_disks();
        reset_before_next_move = false;
    }

    // Make visual move:
    // Get the top disk from the source peg.
    var disk = $('#peg' + source + ' div.disk').first();
    // And drop it onto the target peg.
    $('#peg' + target).prepend(disk);

    // Playback of selected instrument.
    remove_all_glow();

    var selected_instrument = $('#instrument' + target).val();
    if (selected_instrument != INST_SILENT) {
        $('#instrument' + target).addClass('glower_active');
        glow_deactivation_timer = setTimeout(remove_all_glow, 1000);

        play_instrument(selected_instrument);
    }

    // Highlight current notation or rest in the abc notation.
    var abcmeasure = Math.floor(abc_note_index / timesignature);
    var abcnote = abc_note_index % timesignature; 

    $('.abcjs-note').removeClass('current_note');
    $('.abcjs-rest').removeClass('current_note');
    $('.abcjs-mm' + abcmeasure + '.abcjs-n' + abcnote).addClass('current_note');

    // Overall notes played. This only resets on a new start.
    note_play_count++;
    
    // What note within the abc-notation is played next? This only resets after a full loop.
    abc_note_index++;

    // Figure out next move to play. This is complicated by the loop- and addreverse-options.
    if (!reverse) {
        // Playing forward.
        current_move = current_move + 1;
        if (current_move == moves.length) {
            // Reached the end. Do we want to play in reverse next?
            if (addreverse) {
                // Yes. Set reverse flag and adjust current_move.
                reverse = true;
                current_move = moves.length-1;
            } else {
                // No. Don't reverse.
                current_move = 0;
                abc_note_index = 0;
                reset_before_next_move = true;
            
                // Loop?
                if (!loop) {
                    // No. Stop. But we are ready to restart on the next click on play.
                    set_playing(false);
                    
                    if (recording) {
                        record_toggle();
                    }
                } 
            }
        }
    } else {
        // Playing in reverse.
        current_move = (current_move-1);
        if (current_move == -1) {
            // Back at the start. Are we looping?           
            reverse = false;
            current_move = 0;
            abc_note_index = 0;

            if (!loop) {
                // Not looping. Stop. But we are ready to start playing again.
                set_playing(false);
                
                if (recording) {
                    record_toggle();
                }
            }
        }
    } 
    
    // Still playing? Schedule next move.
    if (playing) {
        play_move_timer = setTimeout(play_move, (60/bpm*1000));
    } else {
        play_move_timer = null;
    }
}

function step() {
    console.log('step()');

    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);

    play_move();
}

function play() {
    console.log('play()');

    if (playing) {
        // Pause
        if (play_move_timer) {
            clearTimeout(play_move_timer);
            play_move_timer = null;
        }
        set_playing(false);
    } else {
        // Play
        set_playing(true);
        if (!play_move_timer) {
            play_move();
        }
    }
}

function reset() {
    console.log('reset()');

    if (play_move_timer) {
        clearTimeout(play_move_timer);
        play_move_timer = null;
    }
    set_playing(false);
    
    init_board();
}

function init_board() {
    console.log('init_board()');
    
    Hanoi(pegs, disks);
    update_moves_label();

    // Update Screen to initial conditions
    
    // Clear all pegs and disks
    create_pegs();
    create_disks();

    current_move = 0;
    note_play_count = 0;
    abc_note_index = 0;
    
    abc_render();
}

function custom_instrument_load(e) {
    // console.log('custom_instrument_load()');

    custom_instrument_file = e.target.files[0];
    custom_instrument_file.arrayBuffer().then(function(arrayBuffer) {
        audio_context.decodeAudioData(arrayBuffer).then(function(audioBuffer) {
            custom_instrument_buffer = audioBuffer;
            update_ui();
            custom_instrument_preview();
        })
    });
};

function custom_instrument_preview() {
    // console.log('custom_instrument_preview()');

    var source = audio_context.createBufferSource();
    source.buffer = custom_instrument_buffer;
    source.connect(gain_node);
    source.start();
}

function custom_instrument_add() {
    // console.log('custom_instrument_add()');
    
    var abcnote = $('#text_custom_instrument_note').val();

    // TODO: Validate ABC note to not break notation.

    var newinstrument = true;
    for(var instrument_index = 0; instrument_index < instruments.length; instrument_index++) {
        if (instruments[instrument_index][INST_NAME] == custom_instrument_file.name) {
            // Instrument exists. Update information.
            instruments[instrument_index][INST_NOTE] = abcnode;
            instruments[instrument_index][INST_BUFFER] = custom_instrument_buffer;
        } 
    }

    if (newinstrument) {
        // New instrument. Append to list and update controls.
        instruments.push([custom_instrument_file.name, abcnote, custom_instrument_buffer]);
        
        var btnid = 'button_instrument_' + (instruments.length-1); 
        $('#preview_buttons').append('<button class="button_instrument custom" id="' + btnid + '">' + custom_instrument_file.name + '</button>');            
        $('#' + btnid).click(play_button_instrument_preview);
        $('.instrument_select').append('<option class="custom" value="' + (instruments.length-1) + '">' + custom_instrument_file.name + '</option>');
    }

    custom_instrument_file = null;
    custom_instrument_buffer = null;

    $('#file_custom_instrument').val('');
    update_ui();
}

function record_toggle() {
    console.log('record_toggle()');

    if (!recording) {
        // Start recording
        $('#audio_record_playback').remove();
        $('#button_record_download').remove();
        $('#div_record').append('<label id="label_record">Recording audio...</label>');
        
        console.log('Now recording');
        recorder.record();

        recording = true;
        update_ui();
    } else {
        // Stop recording.
        $('#label_record').remove();

        recorder.stop();
        recorder.exportWAV(function(blob) {
            var url = URL.createObjectURL(blob);
            var name = 'Towers_of_Annoy_' + moment().format('YYYY-MM-DD-hh-mm-ss') + '.wav';

            $('#div_record').append('<audio id="audio_record_playback" controls="true" src="' + url + '"></audio><a href="' + url + '" download="' + name +'"><button id="button_record_download">Download</button></a>');

            recorder.clear();
            recording = false;
            
            update_ui();
        });
        
    }
}

function analyser_draw() {
    
    analyser_node.getByteFrequencyData(fft_array);
    
    var w = $('#analyser').width();
    var h = $('#analyser').height();

    analyser_context.canvas.width  = w;
    analyser_context.canvas.height = h;

    analyser_context.fillStyle = 'rgb(200, 200, 200)';
    analyser_context.fillRect(0, 0, w, h);
    
    // Center/Zero line.
    analyser_context.lineWidth = 1;
    analyser_context.strokeStyle = "white";
    analyser_context.beginPath();
    analyser_context.moveTo(0, h/2);
    analyser_context.lineTo(w, h/2);
    analyser_context.stroke(); 

    var dx = Math.min(15, w / fft_array.length);
    var m = dx/10;
    var x = (w - (dx * fft_array.length)) / 2;
    
    // Bar graph
    analyser_context.fillStyle = 'rgb(230,230,230)';
    for(var i = 0; i < fft_array.length; i++) {
        var bar_height = fft_array[i] / 255.0 * h; // 0..255 mapped to 0..canvas-height

        analyser_context.fillRect(x+m, (h - bar_height)/2, dx-2*m, bar_height);

        x += dx;
    }

    requestAnimationFrame(analyser_draw);
}

$(document).ready(function() {

    // window.AudioContext = window.AudioContext  || window.webkitAudioContext;
    audio_context = new AudioContext();
    
    analyser_node = audio_context.createAnalyser();
    analyser_node.fftSize = 128;
    fft_array = new Uint8Array(analyser_node.frequencyBinCount);

    gain_node = audio_context.createGain();
    compressor_node = audio_context.createDynamicsCompressor();

    gain_node.connect(compressor_node);
    compressor_node.connect(analyser_node);
    analyser_node.connect(audio_context.destination);

    recorder = new Recorder(analyser_node);

    for(var instrument_index = 0; instrument_index < instruments.length ; instrument_index++) {
        $('#preview_buttons').append('<button class="button_instrument" id="button_instrument_' + instrument_index + '">' + instruments[instrument_index][INST_NAME] + '</button>');            
    }
    $('.button_instrument').click(play_button_instrument_preview);

    new BufferLoader(
        function(data) {
            console.log('Samples loaded.');

            // Set up default instruments in order of samples in the instrument array. These are used
            // automatically when pegs are added. 
            for(var instrument_index = 0 ; instrument_index < instruments.length ; instrument_index++) {
                saved_instruments.push(instrument_index);
            }

            update_ui();
            init_board();            
        }
    ).load_all();

    $('#slider_pegs').on('input change', update_ui);
    $('#slider_disks').on('input change', update_ui);
    $('#slider_volume').on('input change', update_ui);
    $('#slider_bpm').on('input change', update_ui);
    $('#slider_timesignature').on('input change', update_ui);
    
    $('#checkbox_loop').on('change', update_ui);
    $('#checkbox_addreverse').on('change', update_ui);
    $('#checkbox_colornotes').on('change', update_ui);

    $('.button_step').click(step);
    $('.button_play').click(play);
    $('.button_reset').click(reset);

    $('#file_custom_instrument').on('change', custom_instrument_load);
    $('#button_custom_sample_preview').click(custom_instrument_preview);
    $('#button_custom_sample_add').click(custom_instrument_add);

    $('#button_record').click(record_toggle);

    analyser_canvas = $('#analyser');
    analyser_context = analyser_canvas[0].getContext("2d");

    var urlvars = getUrlVars();

    // Initialize the visualization loop.
    analyser_draw();

    update_ui();
})

</script>

</html>

